<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Fitting - Finding the Planets</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A book accompanying a workshop to find the planets around Trappist-1.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        
        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="title.html">Finding The Planets</a></li><li class="affix"><a href="about.html">What is this book about</a></li><li><a href="background.html"><strong aria-hidden="true">1.</strong> Background</a></li><li><ol class="section"><li><a href="background/trappist-1.html"><strong aria-hidden="true">1.1.</strong> Trappist-1</a></li><li><a href="background/kepler.html"><strong aria-hidden="true">1.2.</strong> Kepler Spacecraft</a></li></ol></li><li><a href="science.html"><strong aria-hidden="true">2.</strong> Science</a></li><li><ol class="section"><li><a href="science/discovery.html"><strong aria-hidden="true">2.1.</strong> Exo-planet Discovery</a></li><li><a href="science/position.html"><strong aria-hidden="true">2.2.</strong> Observing Position</a></li><li><a href="science/doppler.html"><strong aria-hidden="true">2.3.</strong> Doppler Effect</a></li></ol></li><li><a href="transit.html"><strong aria-hidden="true">3.</strong> Transit Method</a></li><li><ol class="section"><li><a href="transit/light_curve.html"><strong aria-hidden="true">3.1.</strong> What To Look For</a></li></ol></li><li><a href="finding.html"><strong aria-hidden="true">4.</strong> Finding Planets</a></li><li><ol class="section"><li><a href="finding/fits.html"><strong aria-hidden="true">4.1.</strong> FITS</a></li><li><a href="finding/csv.html"><strong aria-hidden="true">4.2.</strong> CSV</a></li><li><a href="finding/image.html"><strong aria-hidden="true">4.3.</strong> Image</a></li><li><a href="finding/collage.html"><strong aria-hidden="true">4.4.</strong> Collage</a></li><li><a href="finding/brightness.html"><strong aria-hidden="true">4.5.</strong> Brightness</a></li><li><a href="finding/detrend.html"><strong aria-hidden="true">4.6.</strong> Detrend</a></li><li><a href="finding/filter.html"><strong aria-hidden="true">4.7.</strong> Filter</a></li><li><a href="finding/median.html"><strong aria-hidden="true">4.8.</strong> Median</a></li><li><a href="finding/fitting.html" class="active"><strong aria-hidden="true">4.9.</strong> Fitting</a></li></ol></li><li><a href="reflection.html"><strong aria-hidden="true">5.</strong> Reflection</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">Finding the Planets</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="finding/fitting.html#fitting" id="fitting"><h1>Fitting</h1></a>
<p>We have created a plot of the median.</p>
<p><img src="image/median.png" alt="The median of the filtered brightness" /></p>
<p>We would like to find planets in it. Finding planets amounts to selecting a
transit curve that nicely fits our data. We our going to divide that task in the
following sub-tasks.</p>
<ol>
<li>Generating a transit curve series</li>
<li>Iterating over all transit curve parameters</li>
<li>Scoring each candidate transit curve and selecting the best</li>
</ol>
<p>Let us create a module for this as well. We will call it <code>fit</code>.</p>
<a class="header" href="finding/fitting.html#transit-curves" id="transit-curves"><h2>Transit Curves</h2></a>
<p><img src="image/period.png" alt="Multiple periods of a transit curves" /></p>
<p>The above image shows a typical transit curve where the planet transits the host
star multiple times. From this diagram we can learn about the parameters that
make up such a transit.</p>
<p>Below we list the parameters important in our transit curve.</p>
<ol>
<li><strong>Period</strong>. The time between the start of one transit and the start of the
next transit.</li>
<li><strong>Base</strong>. Height of the line, when no planet transits. This is often
normalized, but because of the choices we made, we need this parameter.</li>
<li><strong>Depth</strong>. How far the luminosity drops when the planets transits. This is
related to the size of the planet.</li>
<li><strong>Duration</strong>. How long the luminosity stays at full depth.</li>
<li><strong>Decay</strong>. How much time it takes the luminosity to go from the <code>base</code> to
<code>depth</code>. In our model the attack, i.e. time it takes the luminosity to go
from <code>depth</code> back to <code>base</code>, and decay are the same.</li>
<li><strong>Phase</strong>. Where in the period does the periodic function start.</li>
</ol>
<p>Below you find a <code>struct</code> and an implemented constructor that can track this
data.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Transit {
    period: f64,
    base: f64,
    depth: f64,
    duration: f64,
    decay: f64,
    phase: f64,
}

impl Transit {
    fn new((period, base, depth, duration, decay, phase): (f64,f64,f64,f64,f64,f64)) -&gt; Transit {
        Transit { period, base, depth, duration, decay, phase }
    }
}
#}</code></pre></pre>
<p>Notice that the <code>new</code> function accepts a tuple of floating point numbers. We
will use this when we iterate over the parameters.</p>
<p>What we also want to know is, when we have got a <code>time</code>, what is the
corresponding value of this transit curve. For that we are going to implement a
<code>value</code> method on `Transit</p>
<p>What we also want to know is, when we have got a <code>time, what is the corresponding value of this transit curve. For that we are going to implement a</code>value method on <code>Transit</code>.</p>
<p>The interesting times are</p>
<ol>
<li>Before the decay. The value should be <code>base</code></li>
<li>During the decay. The value should linearly interpolate between <code>base</code> and
<code>base</code> - <code>depth</code>.</li>
<li>During full transit. The value should be <code>base</code> - <code>depth</code></li>
<li>During the attack. The value should linearly interpolate between <code>base</code> -
<code>depth</code> and <code>base</code>.</li>
<li>After the transit. The value should be <code>base</code>.</li>
</ol>
<p>Implement the above logic into a <code>value</code> method for <code>Transit</code>.</p>
<a class="header" href="finding/fitting.html#iterate-parameters" id="iterate-parameters"><h2>Iterate Parameters</h2></a>
<p>Our transit curve has five parameters. We would like to generate candidate
transit curves and check how well they fit our data. This can be accomplished by
iterating over the five parameters, and mapping them into a transit curve.</p>
<a class="header" href="finding/fitting.html#floatiterator" id="floatiterator"><h3>FloatIterator</h3></a>
<p>We will first focus on an iterator for a single <code>f64</code>. We want all floating
point numbers between a <code>start</code> and <code>finish</code>, increasing each new number with a
certain <code>step</code>. We will create a <code>struct</code> that keeps track of where we are.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct FloatIterator {
    start: f64,
    finish: f64,
    step: f64,
    current: u64,
}
#}</code></pre></pre>
<p>Implementing a <code>new</code> constructor should set the <code>current</code> to <code>0</code> and accept
<code>start</code>, <code>finish</code> and step as parameters.</p>
<p>Next we need to implement <code>Iterator</code> for <code>FloatIterator</code>. We must import
<code>std::iter::Iterator</code> so that we can easily reference it in our code. In the
<code>next</code> method of the <code>Iterator</code> trait we need to decide if we need to return a
<code>Some</code> or a <code>None</code>. This depends on the our intended return value. I.e. if the
value <code>start + step * current</code> is less then or equal to our <code>finish</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Iterator for FloatIterator {
    type Item = f64;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let value = self.start + self.step * (self.current as f64);

        if value &lt;= self.finish {
            self.current += 1;

            Some(value)
        } else {
            None
        }
    }
}
#}</code></pre></pre>
<p>This wraps up our <code>FloatIterator</code>.</p>
<a class="header" href="finding/fitting.html#exemplar-tupleiterator" id="exemplar-tupleiterator"><h3>Exemplar TupleIterator</h3></a>
<p>Next we are going to create a <code>TupleIterator</code>. It is going to show all the
necessary tools to create the actual <code>TupleIterator</code> we want, without getting
distracted by the tedious details.</p>
<p>Because we want to express multiple times a range of floating point numbers we
are interested in, we are going to create a <code>struct</code> to keep track of <code>start</code>,
<code>finish</code> and <code>step</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct FloatRange {
    start: f64,
    finish: f64,
    step: f64,
}
#}</code></pre></pre>
<p>implementing a <code>new</code> constructor for <code>FloatRange</code> is nothing more than excepting
the correct parameters and passing them in the struct. Having a <code>FloatRange</code>
allows us to ask it for the value belonging to a certain index. Let's extend the
implementation of <code>FloatRange</code> with an <code>index</code> function. The actual
implementation looks very familiar.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn index(&amp;self, index: u64) -&gt; Option&lt;f64&gt; {
    let value = self.start + self.step * (index as f64);

    if value &lt;= self.finish {
        Some(value)
    } else {
        None
    }
}
#}</code></pre></pre>
<p>Now that we can express the floating point range we are interested in, we can
use that in our <code>TupleIterator</code>. The responsibility of the <code>TupleIterator</code> is to
keep track of two indices into two separate <code>FloatIterator</code>. Because we need to
be able to &quot;restart&quot; the <code>FloatIterator</code> we are not actually use a
<code>FloatIterator</code>. Instead we choose to do the iterating our selves.</p>
<p>We start with a structure that will keep track for us.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct TupleIterator {
    first: FloatRange,
    second: FloatRange,
    current: (u64, u64),
}
#}</code></pre></pre>
<p>It looks a lot like the <code>FloatIterator</code>. The main difference is that we need to
keep track of two different ranges, and two different indices into these
iterators. Implementing a new is just like the <code>FloatIterator</code> little more than
accepting the correct parameters and initializing the current indices to
<code>(0,0)</code>.</p>
<p>Now for implementing <code>Iterator</code> for <code>TupleIterator</code>. It comes down to keeping
track of the right indices. Let's look at the implementation.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Iterator for TupleIterator {
    type Item = (f64, f64);

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let (first_index, second_index) = self.current;

        match self.first.index(first_index) {
            Some(first_value) =&gt; {
                match self.second.index(second_index) {
                    Some(second_value) =&gt; {
                        self.current = (first_index, second_index + 1);

                        Some((first_value, second_value))
                    },

                    None =&gt; {
                        self.current = (first_index + 1, 0);

                        self.next()
                    },
                }
            },

            None =&gt; None,
        }
    }
}
#}</code></pre></pre>
<p>Reading the code, we discover that we determine two values, one for each
<code>FloatRange</code>. If the first <code>FloatRange</code> return <code>None</code> we are done. If it returns
some value, we see what the second <code>FloatRange</code> returns. If that also returns
some value, we do the following things.</p>
<ol>
<li>Increment the second index.</li>
<li>Return the tuple of values.</li>
</ol>
<p>If the second <code>FloatRange</code> doesn't return some value, we know that it exhausted
its range. We then increment the first index, resetting the second index. In
effect we want to the second iterator from scratch, but with a new first value.
Next we use the power of recursion to determine what the value should be with
the new indices.</p>
<p>Although it doesn't look pretty, it does its job. It is your task to extend this
example to iterate over all transit parameters.</p>
<a class="header" href="finding/fitting.html#score" id="score"><h2>Score</h2></a>
<p>We are going to score a <code>Transit</code> with the
<a href="https://en.wikipedia.org/wiki/Least_squares"><em>least squares</em></a> method. This
method sums the squares of the difference between two series. That is easier
said than done. Lets look at following code.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn least_squares(xs: &amp;Vec&lt;f64&gt;, ys: &amp;Vec&lt;f64&gt;) -&gt; f64 {
    xs.iter().zip(ys)
        .map(|(a,b)| (a-b).powi(2))
        .sum()
}
#}</code></pre></pre>
<p>We define a function names <code>least_squares</code> that accepts to vectors of floating
points numbers. Next we recognize our dear friend: the <code>iter</code> method. We use it
on the first vector and zip it with the second vector. On the vector of pairs we
map the function that calculates the squared difference. We finish with summing
all the numbers, getting our result.</p>
<p>With all the parts in place we are ready to start processing.</p>
<a class="header" href="finding/fitting.html#processing" id="processing"><h2>Processing</h2></a>
<p>We need to compare candidate transit curves with our median, so we need to read our <code>median.csv</code>. Because we would like to process the times and the values separedly we use the <code>unzip</code> trick we learned earlier.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let (times, values): (Vec&lt;f64&gt;, Vec&lt;f64&gt;) = raw
    .iter()
    .cloned()
    .unzip();
#}</code></pre></pre>
<p>Processing consist for a big part of a main loop that iterates over our transit parameters. This is depend on a number of <code>FloatRange</code>s and this is where you can shine. By looking at your <code>median.csv</code> data you can guess good ranges, and with some luck you will find planets.</p>
<p>We need to keep track of the best transit curve. So we initialize variables before our main loop.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut best_score = f64::MAX;
let mut best_transit: Option&lt;Transit&gt; = None;
#}</code></pre></pre>
<p>In order to make use of the <code>f64::MAX</code> we need to import <code>std::f64</code>. Not that the best score will actually be the lowest value, so it is save to initialize it to the maximum value.</p>
<p>Inside our loop, we can create a transit curve from the parameters.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let transit = Transit::new(parameters);
#}</code></pre></pre>
<p>The <code>transit</code> can be used to determine the values at the times we observed by mapping over the <code>times</code> and using the <code>value</code> method.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let transit_values: Vec&lt;f64&gt; = times.iter().map(|t| transit.value(t)).collect();
#}</code></pre></pre>
<p>Scoring is little more than calling the right function.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let score = least_squares(&amp;transit_values, &amp;values);
#}</code></pre></pre>
<p>Now that we have the score, we need to compare it with the best score we now about, and update our best candidate accordingly.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
if score &lt; best_score {
    best_score = score;
    best_transit = Some(transit.clone());
}
#}</code></pre></pre>
<p>When the loop finishes we would like to know which transit is the best. So we prepare to print it to console, and calculate the actual values, which you can write to a CSV file.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let best_transit = best_transit.unwrap();
let best_transit_values: Vec&lt;f64&gt; = times.iter().map(|t| best_transit.value(t)).collect();
println!(&quot;{:?}&quot;, best_transit);

let result = times.iter().zip(best_transit_values);
#}</code></pre></pre>
<p>Lets fly through our candidates and see what planet you can find.</p>
<a class="header" href="finding/fitting.html#further-considerations" id="further-considerations"><h2>Further Considerations</h2></a>
<p>How do you know that you implemented the various libraries correctly? Have you tested them?</p>
<p>The way that we generate our transit parameters is going through all possible values. This seems a bit wastefull. Can you come up with a better way? Discussing your thoughts with somebody.</p>
<p>We used the method of least squares to score a transit curve. What other scoring mechanism can you think of. What difference would it make?</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="finding/median.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="reflection.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="finding/median.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="reflection.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
