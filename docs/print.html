<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Finding the Planets</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A book accompanying a workshop to find the planets around Trappist-1.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        
        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="title.html">Finding The Planets</a></li><li class="affix"><a href="about.html">What is this book about</a></li><li><a href="background.html"><strong aria-hidden="true">1.</strong> Background</a></li><li><ol class="section"><li><a href="background/trappist-1.html"><strong aria-hidden="true">1.1.</strong> Trappist-1</a></li><li><a href="background/kepler.html"><strong aria-hidden="true">1.2.</strong> Kepler Spacecraft</a></li></ol></li><li><a href="science.html"><strong aria-hidden="true">2.</strong> Science</a></li><li><ol class="section"><li><a href="science/discovery.html"><strong aria-hidden="true">2.1.</strong> Exo-planet Discovery</a></li><li><a href="science/position.html"><strong aria-hidden="true">2.2.</strong> Observing Position</a></li><li><a href="science/doppler.html"><strong aria-hidden="true">2.3.</strong> Doppler Effect</a></li></ol></li><li><a href="transit.html"><strong aria-hidden="true">3.</strong> Transit Method</a></li><li><ol class="section"><li><a href="transit/light_curve.html"><strong aria-hidden="true">3.1.</strong> What To Look For</a></li></ol></li><li><a href="finding.html"><strong aria-hidden="true">4.</strong> Finding Planets</a></li><li><ol class="section"><li><a href="finding/languages.html"><strong aria-hidden="true">4.1.</strong> Languages</a></li><li><a href="finding/rust.html"><strong aria-hidden="true">4.2.</strong> Rust</a></li><li><ol class="section"><li><a href="finding/rust/fits.html"><strong aria-hidden="true">4.2.1.</strong> FITS</a></li><li><a href="finding/rust/csv.html"><strong aria-hidden="true">4.2.2.</strong> CSV</a></li><li><a href="finding/rust/image.html"><strong aria-hidden="true">4.2.3.</strong> Image</a></li><li><a href="finding/rust/collage.html"><strong aria-hidden="true">4.2.4.</strong> Collage</a></li><li><a href="finding/rust/brightness.html"><strong aria-hidden="true">4.2.5.</strong> Brightness</a></li><li><a href="finding/rust/detrend.html"><strong aria-hidden="true">4.2.6.</strong> Detrend</a></li><li><a href="finding/rust/filter.html"><strong aria-hidden="true">4.2.7.</strong> Filter</a></li><li><a href="finding/rust/median.html"><strong aria-hidden="true">4.2.8.</strong> Median</a></li><li><a href="finding/rust/fitting.html"><strong aria-hidden="true">4.2.9.</strong> Fitting</a></li></ol></li><li><a href="finding/javascript.html"><strong aria-hidden="true">4.3.</strong> JavaScript</a></li><li><ol class="section"><li><a href="finding/javascript/fits.html"><strong aria-hidden="true">4.3.1.</strong> FITS</a></li><li><a href="finding/javascript/csv.html"><strong aria-hidden="true">4.3.2.</strong> CSV</a></li><li><a href="finding/javascript/image.html"><strong aria-hidden="true">4.3.3.</strong> Image</a></li><li><a href="finding/javascript/collage.html"><strong aria-hidden="true">4.3.4.</strong> Collage</a></li><li><a href="finding/javascript/brightness.html"><strong aria-hidden="true">4.3.5.</strong> Brightness</a></li><li><a href="finding/javascript/detrend.html"><strong aria-hidden="true">4.3.6.</strong> Detrend</a></li><li><a href="finding/javascript/filter.html"><strong aria-hidden="true">4.3.7.</strong> Filter</a></li><li><a href="finding/javascript/median.html"><strong aria-hidden="true">4.3.8.</strong> Median</a></li><li><a href="finding/javascript/fitting.html"><strong aria-hidden="true">4.3.9.</strong> Fitting</a></li></ol></li></ol></li><li><a href="reflection.html"><strong aria-hidden="true">5.</strong> Reflection</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">Finding the Planets</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#finding-the-planets" id="finding-the-planets"><h1>Finding The Planets</h1></a>
<p>Exo-planets, planets that orbits distant stars, are a scientific marvel that appeal to our adventurous mind. In artistâ€™s impressions they are portrayed as beautiful alien worlds dancing around their host star. The real world is not so visual but far more interesting.</p>
<p>During this workshop, you will learn the tricks and develop the tools with which you can analyse real-outer-world data in search of exo-planets. You will get your amateur astronomer merit badge when you find the hidden worlds.</p>
<a class="header" href="print.html#what-is-this-book-about" id="what-is-this-book-about"><h1>What is this book about</h1></a>
<p>This book is an compendium to the workshop <em>Finding the Planets</em>. The workshop
walks you through various techniques and teaches you how to detect planets in
photo-metric data.</p>
<p>It starts with observations of <a href="https://en.wikipedia.org/wiki/TRAPPIST-1">Trappist-1</a>, a star system only 40
light-years from earth. It ends with finding the planets among the massaged
data. Along the way you learn how to clean up data, what we are looking for, and
how to find the actual planets.</p>
<p>This book challenges you to become a planet-hunter yourself. Together you and
your trusty silicon companion go on a journey to explore the riches of the
universe. So put on your science hat and go find those planets.</p>
<a class="header" href="print.html#background" id="background"><h1>Background</h1></a>
<p>Before we strap into our science-craft let's set the scene by learning about
the background of all those marvelous discoveries.</p>
<p>In the following chapters, you will learn more about Trappist-1, how it was
discovered and the data that we will use to find its planets.</p>
<a class="header" href="print.html#trappist-1" id="trappist-1"><h1>Trappist-1</h1></a>
<p>Trappist-1 is a star system 39 light-years from Earth. A light-year is the
distance light travels in one year. That is approximately 369 trillion
kilometers. Even though this seems an astronomically large distance, on a
galactic scale, Trappist-1 and the sun are close neighbors.</p>
<a class="header" href="print.html#kepler-spacecraft" id="kepler-spacecraft"><h1>Kepler Spacecraft</h1></a>
<p>The Kepler spacecraft is a satellite that orbits the sun and acts as an
telescope observing the universe without earths atmosphere interfering.</p>
<p>It was launched by NASA, as part of the Discovery Program. A program which
focused on a series of lower-cost, highly focused space missions.</p>
<a class="header" href="print.html#science" id="science"><h1>Science</h1></a>
<p>In this part we will explore the science behind exo-planet discovery. We will
detail the different methods of detecting exo-planets, and do some calculations
on what the expect.</p>
<a class="header" href="print.html#exo-planet-discovery" id="exo-planet-discovery"><h1>Exo-planet Discovery</h1></a>
<a class="header" href="print.html#direct-observation" id="direct-observation"><h2>Direct Observation</h2></a>
<p>One way of discovering exo-planets is by direct observations. You take a
telescope point it in the right direction, this involves a lot of luck, and hope
to spot a planet orbiting around a distant star.</p>
<p>This technique can be used to discover the moons of Jupiter, but because most of
the stars are so far away, it quickly becomes impossible. Instead we should use
our knowledge to infer the existence of exo-planets.</p>
<a class="header" href="print.html#indirect-observation" id="indirect-observation"><h2>Indirect Observation</h2></a>
<p>With direct observations out of the window, the alternative is indirect
observation. This entails to take measurements of a star, analyze the data and
infer the existence of exo-planets.</p>
<p>The following sections and chapters will provide some examples of this method.</p>
<a class="header" href="print.html#observing-position" id="observing-position"><h1>Observing Position</h1></a>
<p>When a planet orbits a star, they do so around a mutual
<a href="https://en.wikipedia.org/wiki/Center_of_mass">center of mass</a>. Because of this
a star will wobble, i.e. it will appear to change its apparent position.</p>
<p>Similar with direct observation, we could try to observe the wobble of a star
directly. This method faces the same problems, i.e. the distances of the stars
are so immense, the wobble becomes all but undetectable.</p>
<p>So we will quickly move on to other methods.</p>
<a class="header" href="print.html#doppler-effect" id="doppler-effect"><h1>Doppler Effect</h1></a>
<p>Just like a blaring whistle of a train drops pitch when it rushes by, light
changes color depending if the light emitter is moving towards us or away
from us. This is called the Doppler effect.</p>
<p>By careful measurement of the Doppler effect in star light one could discover
regularities and infer the existence of planets. Even though this technique is
used to discover exo-planets, we will be making use of a different technique.</p>
<a class="header" href="print.html#transit-method" id="transit-method"><h1>Transit Method</h1></a>
<p>When a planet moves in between its star and the Earth, it will make the star
appear dimmer because it obscures some of the light rays. Despite planets often
being very much smaller than their companion star, this effect is certainly
measurable.</p>
<p>It is the transit method that we will use in this workshop to detect the planets
around Trappist-1.</p>
<a class="header" href="print.html#what-to-look-for" id="what-to-look-for"><h1>What To Look For</h1></a>
<p>We are forming a model of a planet transit in order to make some calculations
what to expect. Our model will be fairly crude, but it will suffices for
understanding key characteristics of light curves.</p>
<p>This section has some math in it. It is used to understand how a light curve
will look when a planet transits. Feel free to skip to the result if you feel
inclined.</p>
<a class="header" href="print.html#light-curve" id="light-curve"><h2>Light Curve</h2></a>
<p>A <a href="https://en.wikipedia.org/wiki/Light_curve">light curve</a> is</p>
<blockquote>
<p>a graph of light intensity of a celestial object or region, as a function of
time.</p>
</blockquote>
<p>It graphs how bright some object appears in the sky over time. Our goal is to
understand what the light curve looks like when a planet transits a star.</p>
<a class="header" href="print.html#model" id="model"><h2>Model</h2></a>
<p>We are modeling our planet transit in the following crude manner. We assume the
star to be a square which radiates uniformly. The total luminosity is
\(I_{0}\). So the luminosity per area \(\rho = \frac{I_{0}}{A}\), where \(A\)
is the total area of the star.</p>
<p>We model our planet as a square as well. We will also assume that the planet
will move with uniform speed across the stars image during the transit. When the
planet is fully in front of the star, it block some of the rays of the star
diminishing the luminosity to \(I_{t} = \rho \left(A - a\right)\), where
\(a\) is the area of the planet.</p>
<p>We are interested in the relative drop in luminosity so we will divide
\(I_{t}\) by \(I_{0}\) to get</p>
<p>\[
\frac{I_{t}}{I_{0}} = \frac{\rho \left(A - a\right)}{\rho A} = 1 - \frac{a}{A}
\]</p>
<p>So the entire light curve looks something like this.</p>
<p><img src="image/light-curve.png" alt="A light curve for a planet transition" /></p>
<a class="header" href="print.html#characteristics" id="characteristics"><h2>Characteristics</h2></a>
<p>Even though our model is crude it does portrait important characteristics. We
expect to find a dip in the luminosity when a planet transits its star. When a
bigger planets transits a star we expect the dip to be more pronounced, since
more of the star light is blocked from our view. Our model predicts this as
well.</p>
<p>Astronomers have made far better models of planets, but our model will do just
fine in finding the period of exo-planets.</p>
<a class="header" href="print.html#how-big-dip-to-expect" id="how-big-dip-to-expect"><h2>How big dip to expect</h2></a>
<p>Let's plug in some values of a star and a planet we know to see how big a dip we
would expect. Jupiter orbits our Sun, so a distant observer could try to infer
Jupiter's existence by observing the sun's luminosity. We will calculate the dip
they can expect.</p>
<table><thead><tr><th> Celestial Object </th><th> Radius (km) </th><th>          Area </th></tr></thead><tbody>
<tr><td> Sun              </td><td>      696392 </td><td> 1.5235525e+12 </td></tr>
<tr><td> Jupiter          </td><td>       69911 </td><td> 1.5354684e+10 </td></tr>
</tbody></table>
<p>The table above lists the radius and area of the sun and Jupiter. Plugging this
into our model we determine that</p>
<p>\[
1 - \frac{a}{A} = 1 - \frac{1.5\mathrm{e}{+10}}{1.5\mathrm{e}{+12}} = 1 - 1\mathrm{e}{-2} \approx 0.99
\]</p>
<p>That is only a one percentage drop!</p>
<a class="header" href="print.html#finding-planets" id="finding-planets"><h1>Finding Planets</h1></a>
<p>The following chapters will guide you in writing software that will detects
planets around Trappist-1.</p>
<p>Two things will go hand in hand. Explaining what to do followed by you
implementing that in your favorite programming language.</p>
<a class="header" href="print.html#format" id="format"><h2>Format</h2></a>
<p>We will chose to adhere to the following format. In almost every chapter we will
output a Comma Separated Values (CSV) file. That file will serve as input for
the next chapter.</p>
<p>Although this could be optimized in a single pipeline, foregoing the need to
write and read CSV, with this format we have to ability to reflect. This will
aid us in understanding our task at hand.</p>
<a class="header" href="print.html#outline" id="outline"><h2>Outline</h2></a>
<p>The following outline is typical for almost all the activities we are going to
do in this workshop.</p>
<ol>
<li>Read data</li>
<li>Process data</li>
<li>Write data</li>
</ol>
<p>Processing could be any of, but not limited to, transforming, filtering,
analyzing or fitting. Now processing will be generating image data.</p>
<p>This could be your first encounter with some of the libraries we use. When we
start using a library for the first time, we are going to be very specific. Once
you get to know the library we leave you to fill in the blanks.</p>
<a class="header" href="print.html#tools" id="tools"><h2>Tools</h2></a>
<p>This workshop can be done in a variety of tools. We provide examples in
different languages, but feel free to use your own tools. If you want to use a
spreadsheet go for it. In principle you could use pen and paper, so think
outside of the box.</p>
<a class="header" href="print.html#further-considerations" id="further-considerations"><h2>Further Considerations</h2></a>
<p>Almost every chapter encourages you to play with what you have created. We hope
too give you some food for thought that might spark your interested. But feel
free to come up with your own questions and observations and don't forget to
share them.</p>
<a class="header" href="print.html#languages" id="languages"><h1>Languages</h1></a>
<p>Below you find links that will take you to language specific treatments of the
workshop. Your are invited to bring your own tables to the table, we would love
to see your way of work</p>
<a class="header" href="print.html#rust" id="rust"><h2>Rust</h2></a>
<p>Rust is a</p>
<blockquote>
<p>systems programming language that runs blazingly fast, prevents segfaults, and
guarantees thread safety.</p>
</blockquote>
<p>We use it in to discover <a href="finding/rust.html">planets</a>.</p>
<a class="header" href="print.html#javascript" id="javascript"><h2>JavaScript</h2></a>
<p>JavaScript is a</p>
<blockquote>
<p>high-level, interpreted programming language. It is a language which is also
characterized as dynamic, weakly typed, prototype-based and multi-paradigm.</p>
</blockquote>
<p>it is a language people love to hate, but we are using it to discover
<a href="finding/javascript.html">planets</a>.</p>
<a class="header" href="print.html#rust-1" id="rust-1"><h1>Rust</h1></a>
<p>This is the start of an exciting scientific journey where we will use
<a href="https://www.rust-lang.org/en-US/">Rust</a> as our tool to find planets around
Trappist-1.</p>
<a class="header" href="print.html#fits" id="fits"><h1>FITS</h1></a>
<p>The results of the NASA Kepler mission on observing Trappist-1 are
<a href="https://keplerscience.arc.nasa.gov/raw-data-for-k2-campaign-12-and-trappist-1-now-available.html">available</a>
to the public. For your ease of use we downloaded the FITS files before hand.</p>
<a class="header" href="print.html#what-are-fits-files" id="what-are-fits-files"><h2>What are FITS files</h2></a>
<p>A <a href="https://en.wikipedia.org/wiki/FITS">FITS</a> file is a</p>
<blockquote>
<p>open standard defining a digital file format useful for storage,
transmission and processing of scientific and other images. FITS is the most
commonly used digital file format in astronomy. Unlike many image formats,
FITS is designed specifically for scientific data and hence includes many
provisions for describing photometric and spatial calibration information,
together with image origin metadata.</p>
</blockquote>
<p>We would like to use the FITS files directly, but unfortunately the
<a href="https://crates.io/crates/fits-rs">library</a> is not production ready yet. We
created a Comma Seperated Values (CSV) file with the relevant data.</p>
<a class="header" href="print.html#csv" id="csv"><h1>CSV</h1></a>
<p>Comma Seperated values play an integral role in this workshop. We don't need an particular sharp tool to process CSV files. Basic reading and writing is more than enough. We are going to use the <code>simple_csv</code> crate for this.</p>
<p>Whenever we use the functionality we are going to explain what we are doing. If you want a head start take a look at the
<a href="https://github.com/daramos/simple_csv">documentation</a>.</p>
<a class="header" href="print.html#image" id="image"><h1>Image</h1></a>
<p>Now that we have our data in a CSV file, we are operating on it. The first thing
that we should do is make an image.</p>
<a class="header" href="print.html#artist-impression" id="artist-impression"><h2>Artist Impression</h2></a>
<p><img src="image/artist-impression.jpg" alt="An artist impression of Trappist-1" /></p>
<p>Often artists are commissioned to create a stunning visualization of new findings.
This is also the case with the Trappist-1 news. Above you find an artist
impression of Trappist-1.</p>
<p>The downside of this is that we could loose track of the actual data that is
used. In order to get a sense of awe for the search of exo-planets, we are
creating our own impression.</p>
<a class="header" href="print.html#creating-an-image" id="creating-an-image"><h2>Creating an image</h2></a>
<p>So go ahead and start a new Rust file named <code>image.rs</code> in the <code>src/bin</code>
directory of your project.</p>
<a class="header" href="print.html#reading-data" id="reading-data"><h3>Reading Data</h3></a>
<p>We will be reading our data from CSV. We will use the crate <code>simple_csv</code> for
that. In order to use it include the following lines in <code>image.rs</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate simple_csv;

use simple_csv::SimpleCsvReader;
#}</code></pre></pre>
<p>The <code>SimpleCsvReader</code> expects some sort of <code>BufReader</code>, a buffered reader. We
can create one from a <code>File</code>. So include the following modules.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fs::File;
use std::io::BufReader;
#}</code></pre></pre>
<p>And in the main function add.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let f = File::open(&quot;../long-cadence.csv&quot;).expect(&quot;input CSV to exist.&quot;);
let buf = BufReader::new(f);
#}</code></pre></pre>
<p>Notice that we are not handling errors in a graceful way. We are just going to
arrange everything correctly and hope for the best.</p>
<p>With the <code>buf</code> we can create a CSV reader and read the first row of our data.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut reader = SimpleCsvReader::new(buf);
let row = reader.next_row().unwrap().unwrap();
#}</code></pre></pre>
<p>The unsightly double <code>unwrap</code> at the end comes from the interplay of the
<code>Iterator</code> trait that has a <code>next</code> function that returns an <code>Option</code>, and the
way <code>simple_csv</code> parses lines from CSV files into a <code>Result</code>. So the first
<code>unwrap</code> unwraps the <code>Option</code>, the second <code>unwrap</code> unwraps the <code>Result</code>.</p>
<p>We should make a mental note when working with the <code>simple_csv</code> crate, we should
mind our <code>unwrap</code>s.</p>
<a class="header" href="print.html#processing-data" id="processing-data"><h3>Processing Data</h3></a>
<p>Our CSV file contains rows of floating point numbers. But the <code>simple_csv</code> crate
returns a slice of Strings. We will need to turn those Strings into floating
point numbers before we can properly process them.</p>
<p>We do this by iterating over the <code>row</code>. Remember how the first column
contained the time? We don't need it now so we will drop it for the moment.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut current_row = row.iter();
current_row.next(); // dropping time
#}</code></pre></pre>
<p>Next we can transform all the measurements in floating point numbers. We can do
that by using the <code>FromStr</code> trait. Import it with <code>use std::str::FromStr</code>. It
provides a method <code>from_str</code> that transforms <code>&amp;str</code> into an other type.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let raw: Vec&lt;f64&gt; = current_row
    .map(|s| f64::from_str(s).unwrap())
    .collect();
#}</code></pre></pre>
<p>Note we need to include a <code>use std::str::FromStr;</code> line at the top of our file.</p>
<p>What we are going to do is map these measurements onto a gray scale that we can
save as an image. We do this by determining the maximum measurement, determining
the relative measurement compared to the maximum, and scaling it the an integer
range from 0 to 255.</p>
<p>The following lines achieve this.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let maximum = raw
    .iter()
    .fold(std::f64::MIN, |acc, v| acc.max(*v));
let data: Vec&lt;u8&gt; = raw
    .iter()
    .map(|s| s/maximum)
    .map(|s| 255.0 * s)
    .map(|s| s.floor() as u8)
    .collect();
#}</code></pre></pre>
<p>It uses a method <code>fold</code> with the following signature</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn fold&lt;B, F&gt;(self, init: B, f: F) -&gt; B
    where
        F: FnMut(B, Self::Item) -&gt; B
#}</code></pre></pre>
<p>It takes something that implements the <code>Iterator</code> trait, a initial value called
<code>init</code> and repeatedly calls <code>f</code>. The function <code>f</code> accepts two arguments. At
first it accepts the initial <code>init</code> value and the first element the <code>Iterator</code>
produces. After that it accepts the previous call to <code>f</code> return value with the
next value of the iterator. A fold returns the final return value of the
function <code>f</code>.</p>
<a class="header" href="print.html#writing-data" id="writing-data"><h2>Writing data</h2></a>
<p>Now that we have the gray-scale data, it is time to write it as an image. For
this we will use the <code>png</code> crate. Before we can use it add</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate png;
#}</code></pre></pre>
<p>To the top of the source file. We also need to include an import statement that
makes our live working with PNGs easier.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use png::HasParameters;
#}</code></pre></pre>
<p>We are going to save the PNG into our working directory. Because the <code>png</code> crate
expects a <code>BufWriter</code> we will have to include the following modules.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::env;
use std::io::{BufWriter, BufReader};
#}</code></pre></pre>
<p>Notice that we already had imported the <code>BufReader</code> module. With these imports
we can create a <code>BufWriter</code> in one fell swoop.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut path = env::current_dir().unwrap();
path.push(format!(&quot;trappist-1.{}.png&quot;, 0));
let file = File::create(path).unwrap();
let ref mut w = BufWriter::new(file);
#}</code></pre></pre>
<p>Now we can hand over this <code>BufWriter</code> to a PNG <code>Encoder</code>, configure it to our
liking, create a PNG <code>Writer</code> and write the data.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut encoder = png::Encoder::new(w, 11, 11);
encoder.set(png::ColorType::Grayscale).set(png::BitDepth::Eight);
let mut writer = encoder.write_header().unwrap();
writer.write_image_data(data.as_slice()).unwrap();
#}</code></pre></pre>
<a class="header" href="print.html#our-image" id="our-image"><h2>Our Image</h2></a>
<p>It is finally time to make our own impression of Trappist-1. Use <code>cargo</code> to
build and run your code.</p>
<pre><code class="language-shell">&gt; cargo build
&gt; cargo run --bin image
</code></pre>
<p>Which creates</p>
<p><img src="image/trappist-1.0.png" alt="Actual Trappist-1 photo" /></p>
<a class="header" href="print.html#appreciate-the-image" id="appreciate-the-image"><h2>Appreciate the Image</h2></a>
<p>At first glance the image can be a little underwhelming. But it is precisely
this image that blew my mind! Being accustomed to the marvelous artist
impression, when I learned about the actual data was 11x11 pixels I was hooked.
How could anyone extract so much information from so little data?</p>
<p><img src="image/trappist-1.0.large.png" alt="10 times enlargement of actual Trappist-1 photo" /></p>
<p>I had to know and I hope you want to know too!</p>
<a class="header" href="print.html#further-considerations-1" id="further-considerations-1"><h2>Further Considerations</h2></a>
<ul>
<li>Make a bigger image with larger &quot;pixels&quot;.</li>
<li>Make an entire series of images, one for each row.</li>
<li>Make a GIF or movie of the images.</li>
</ul>
<a class="header" href="print.html#collage" id="collage"><h1>Collage</h1></a>
<p>In this chapter we will create a Collage of all the image in the long cadence
file. Although it is a bit of a side-track, we will learn valuable things by
looking at the image.</p>
<p>If you want, you can take a <a href="image/collage.png">sneak peek</a>.</p>
<p>We will not go into details of reading the data and writing the transformed
data. We assume that the previous chapters have given enough examples to learn
from. Instead we are going to focus on processing the data.</p>
<a class="header" href="print.html#processing" id="processing"><h2>Processing</h2></a>
<p>There are a few questions we need to answer before we can create our collage.</p>
<ol>
<li>For a row of data and a column in that row, which pixel should we paint?</li>
<li>What color should we paint that pixel?</li>
</ol>
<a class="header" href="print.html#position" id="position"><h3>Position</h3></a>
<p>When we created the single image, we did not have to think about positioning
explicitly. Because we want to make a collage we have some work to do.</p>
<p>First of all, lets state some facts.</p>
<ol>
<li>Each image is 11x11 pixels.</li>
<li>There are 3599 rows of images.</li>
</ol>
<p>The interesting thing about 3599 is that is 61x59. So we could make our collage
almost a square with 61 columns and 59 rows of single images. With 11x11 images
as base our collage will come in at 61x11 = 671 by 59x11 = 649.</p>
<p>Let's start by giving names to things. We start out with the tile base size,
i.e. the size of the original image. We are going to call that <code>BASE</code>. Next we
want 61 of our tiles to go horizontally, and we want 59 of our tiles to go
vertically. We will call these <code>HORIZONTAL_TILES</code> and <code>VERTICAL_TILES</code>
respectively.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const BASE: usize = 11;
const HORIZONTAL_TILES: usize = 61;
const VERTICAL_TILES: usize = 59;
#}</code></pre></pre>
<p>Now we can express all the other dimensions in terms of our <code>BASE</code> and
<code>HORIZONTAL_TILES</code> and <code>VERTICAL_TILES</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const WIDTH: usize = HORIZONTAL_TILES * BASE;
const HEIGHT: usize = VERTICAL_TILES * BASE;
const SIZE: usize = WIDTH * HEIGHT;
#}</code></pre></pre>
<p>For example, <code>SIZE</code> is the number of pixels in our base tile. Let's continue and
figure out where the pixels go. There are two factors that determine the
position of the pixel. The which row that data is from, and which column the
data is in.</p>
<p>We will start with the row. Because we have 61 images along the x-axis of our
collage, the <code>X</code>-offset will be</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let offset_X = row_index % HORIZONTAL_TILES;
#}</code></pre></pre>
<p>The <code>Iter</code> trait has a very nice method:
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.enumerate"><code>enumerate</code></a>.
What it does is besides iterating over the <code>row</code>, it also provides us with the
<code>row_index</code>. We should keep this in mind when we are putting things together.</p>
<p>After <code>HORIZONAL_TILES</code> rows, we need to increase the <code>Y</code>-offset with one. This amounts to</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let offset_Y = row_index / HORIZONTAL_TILES;
#}</code></pre></pre>
<p>Now for the offset within the image. The image is <code>BASE</code>x<code>BASE</code>. So given an original
index in the row, we have for the</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let offset_x = original_index % BASE;
let offset_y = original_index / BASE;
#}</code></pre></pre>
<p>Now we can calculate the target index. For each <code>offset_Y</code> we need to go down an
entire <code>BASE</code> rows in our collage. This is <code>BASE</code>x<code>HORIZONTAL_TILES</code>x<code>BASE</code> (=
7381). For each <code>offset_X</code> we need to shift <code>BASE</code> pixels down. For each
<code>offset_y</code> we need to go down an entire row. This is <code>HORIZONTAL_TILES</code>x<code>BASE</code>
(= 671). Finally, for each <code>offset_x</code> we need to shift 1 pixel
down. All together this is</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let target_index = offset_Y * (BASE * HORIZONTAL_TILES * BASE) +
                   offset_X * BASE +
                   offset_y * (HORIZONTAL_TILES * BASE) +
                   offset_x
#}</code></pre></pre>
<p>With these calculations we know where to paint the image pixel.</p>
<a class="header" href="print.html#color" id="color"><h3>Color</h3></a>
<p>From our experience from creating an image we have a fairly good idea which
color to use. The only difference between the collage and the single image is
that we want to use the same scale for each image.</p>
<p>So instead of dividing our value by the maximum value of a single image, we
should divide by the global maximum.</p>
<p>Create a separate executable that will determine the global maximum of all the
measurements that we can use in determining the color of the pixel.</p>
<a class="header" href="print.html#further-considerations-2" id="further-considerations-2"><h2>Further Considerations</h2></a>
<p>The following suggestions might help your understanding of the problem we
facing, i.e. detecting planets in our image.</p>
<p>Take a long good look at your collage. Write down what you notice about the
image. Ask yourself some questions and discuss your observations with somebody
else.</p>
<p>Why do we need a global maximum? What would happen if we would stick to the
maximum per image? What would that look like, and what would it tell you?</p>
<a class="header" href="print.html#brightness" id="brightness"><h1>Brightness</h1></a>
<p>We are going to detect the planets by observing drops in overall brightness.
Before we are able to do this, we need to calculate the brightness. That is
precisely the objective in this chapter.</p>
<p>We are going to create a CSV file with the first column the time of the
measurement and the second column the brightness at that time.</p>
<a class="header" href="print.html#processing-1" id="processing-1"><h2>Processing</h2></a>
<p>For each row of data we would like to know how much Trappist-1 is radiating.
What we are going to do is the following.</p>
<p>Take a row of data and</p>
<ol>
<li>Convert each value to a <code>f64</code>.</li>
<li>Sum all the values to get the overall brightness.</li>
</ol>
<p>Converting values to a <code>f64</code> is something we did before. We are not going into
details for the conversion.</p>
<p>The summation of all the values can be written down very succinctly because the
<a href="https://doc.rust-lang.org/std/iter/"><code>Iterator</code></a> trait has a trick up it's
sleeve. The <code>Iter</code> trait has a <code>sum</code> method. We can use it to calculate the sum
of all the brightness values. If we have our raw <code>f64</code> values in the variable
<code>raw</code>, we can determine the sum with</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let sum: f64 = raw
    .iter()
    .sum();
#}</code></pre></pre>
<a class="header" href="print.html#removing-background" id="removing-background"><h3>Removing Background</h3></a>
<p>If we take a look at one of the images</p>
<p><img src="image/trappist-1.0.large.png" alt="Enlargement of an image of Trappist-1" /></p>
<p>we see that the background is not pitch black. This means that the background
adds to the brightness, even though it does not contribute to the signal. So we
start our journey with something we will come very familiar with, we will clean
up our data.</p>
<p>What we are going to do is ignore the brightness value of anything below the
average brightness. This transforms the image from above into the image below.</p>
<p><img src="image/trappist-1.0.nobg.large.png" alt="Enlargement of an image of Trappist-1 with background removed" /></p>
<p>Still not perfect, but it is better than nothing.</p>
<p>In order to filter out the unwanted background we are going to need to know the
average. We already know the sum, we just calculated it, so the average can be
determined by</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let average = sum / (row.len() as f64);
#}</code></pre></pre>
<p>Calculating the contribution of the values above the average can still be done
succinctly. What we need to do is filter out the values that we want to sum.
I.e. the values above the average.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let filtered: f64 = raw
    .iter().
    .filter(|&amp;v| *v &gt;= average)
    .fold(0f64, |acc, v| acc+v)
#}</code></pre></pre>
<a class="header" href="print.html#graphing-results" id="graphing-results"><h2>Graphing Results</h2></a>
<p>Once you wrote your brightness results to a CSV file, they are ready for the
following step. But if you are like me you probably want to see your results.
This is where gnuplot comes in.</p>
<p>If you have saved your results as <code>brightness.csv</code>, the following gnuplot
session will plot your data.</p>
<pre><code>set datafile separator ','

plot [2905:2985] &quot;brightness.csv&quot; using 1:2
</code></pre>
<p>We will annotate the above example a little, so that you can use gnuplot on your
own. The <code>simple_csv</code> library outputs CSV files with a comma as separator. This
difference from the default assumption of gnuplot. Luckily this can be remedied
with the first line.</p>
<p>The second line display the core of gnuplot; the <code>plot</code> command. The first
argument, i.e. <code>[2905:2985]</code>, defines the range on the x-axis. It is optional
and will be inferred by gnuplot if it isn't present. If there would be a second
argument of that form, i.e. <code>[min:max]</code>, that would be the range on the y-axis.
Here it is inferred.</p>
<p>The <code>&quot;brightness.csv&quot;</code> argument you probably recognize as the file you wrote
your data to. The <code>plot</code> command will use data in this file to plot.</p>
<p>The last refers to columns in the data. <code>using 1:2</code> tells the plot command to
plot point with the first column as x-coordinate and the second column as
y-coordinate.</p>
<p>For a more extensive explanation of gnuplot we refer you to the
<a href="http://www.gnuplot.info/">gnuplot homepage</a>.</p>
<p>If you have gone to the trouble of outputting the brightness with and without
the background, your plot could look like the one below.</p>
<p><img src="image/brightness-both.png" alt="Plot of brightness, with and without background contribution" /></p>
<a class="header" href="print.html#further-considerations-3" id="further-considerations-3"><h2>Further Considerations</h2></a>
<p>Take a look at your data and write down what stands out to you. Discuss this
with a neighbor.</p>
<p>Why is the average taken as a cut-off value? What are other options?</p>
<p>There is an obvious gap in our data. This is where the Kepler satellite stopped
recording data due to a software reboot initiated by a cosmic ray event.
Although the data was lost, the satellite still operates nominally.</p>
<p>Furthermore there is a trend in the overall brightness, more pronounced in the
data with the background. This is also seen in our collage. We will have to
smooth out that trend and that is precisely what we will in one of the next chapters.</p>
<a class="header" href="print.html#detrend" id="detrend"><h1>Detrend</h1></a>
<p>Take a look the brightness graph you made in the preceding chapter.</p>
<p><img src="image/brightness-nobackground.png" alt="Brightness of Trappist-1" /></p>
<p>Notice how the graph tends to flare up. This is a systemic problem that we
should correct. We are going to do that by finding what trend the graph is
following, and adjusting for that.</p>
<a class="header" href="print.html#processing-2" id="processing-2"><h2>Processing</h2></a>
<p>Before, we processed each row individually. Now we need to operate on the entire
sequence. So instead iterating over each row, we are going to transform it
directly.</p>
<p>Because a <code>SimpleCsvReader</code> is an <code>Iterator</code> we can use our tricks on it. The
idiosyncrasies of the <code>SimpleCsvReader</code> make that we first need to unwrap a row.
Next we can map over the row of data and collect into a vector of tuples, the
entry being the time and the second entry being the brightness.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let raw: Vec&lt;(f64, f64)&gt; = reader
    .map(|r| r.unwrap())
    .map(data)
    .collect();
#}</code></pre></pre>
<p>The function <code>data</code> has the following signature</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn data(row: Vec&lt;String&gt;) -&gt; (f64, f64)
#}</code></pre></pre>
<p><code>data</code> is responsible for turning the raw columns of our CSV into <code>f64</code> brightness values,
and selecting the correct ones.</p>
<p>Up until now we never returned more than two or three values. For our current
plan we are going to return more. In order to keep track of our data, we are
going to create a <code>struct</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct DetrendData {
    time: f64,
    brightness: f64,
    trend: f64,
    difference: f64,
}
#}</code></pre></pre>
<p>We have created a few entries, some familiar, some unfamiliar. <code>time</code> and
<code>brightness</code> are pretty self-explanatory. <code>difference</code> is intended to hold the
difference between the <code>brightness</code> and the <code>trend</code>.</p>
<p>But how do we calculate the trend?</p>
<a class="header" href="print.html#strategies" id="strategies"><h3>Strategies</h3></a>
<p>Let us reflect on what we are trying to achieve. We have some data points
\(y_{0}, y_{1}, \ldots, y_{n}\). We have a model that predicts that these
values fluctuate around a given mean \(Y\), but for some reason or another, it
doesn't.</p>
<p>Instead the values fluctuate around some function \(f\), for which we don't
now the shape or form. This is called the <em>trend</em>.</p>
<p>Our goal is to approximate the trend function \(f\) by a function that we can
calculate from the data. Next we can analyze the actual signal by removing the
trend. In effect we will look at the de-trended signal \(y_{0} - t(0), y_{1} -
t(1), \ldots, y_{n} - t(n)\). Here \(t\) is our approximation for the trend.</p>
<p>We shall do this by providing the values of our approximation.</p>
<p>There are numerous strategies for determining the trend in a sequence of data.
Below you can find a strategy we have selected for this workshop.</p>
<a class="header" href="print.html#weighted-trend" id="weighted-trend"><h4>Weighted Trend</h4></a>
<p>With the notations from the preceding section the weighted trend algorithm is as
follows. First you pick a parameter \(\alpha\) such that it lies between zero
and one, i.e. \(0 \le \alpha \le 1\).</p>
<p>Next we will explain how to calculate each point of our approximation to the
trend.</p>
<ul>
<li>\(t_{0} = y_{0}\). I.e. our first approximation is the first value of our
sequence of data.</li>
<li>\(t_{i} = \alpha y_{i} + (1-\alpha) t_{i-1}\). I.e. our trend tends towards
the new value of our sequence, but is a but reluctant. It tends to stick to
the previous values.</li>
</ul>
<p>Let's implement this algorithm. With our <code>DetrendData</code> structure, we have an
opportunity to directly implement the different branches of our algorithm. We
start an <code>impl</code> block for <code>DetrendData</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl DetrendData {

}
#}</code></pre></pre>
<p>Next we are going to translate the first branch of the algorithm. Since our data
gets delivered to us in the form of a <code>(f64, f64)</code> pair, we better accept it as
an argument.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn initial((time, brightness): (f64, f64)) -&gt; DetrendData {
    DetrendData {
        time: time,
        brightness: brightness,
        trend: brightness,
        difference: 0f64,
    }
}
#}</code></pre></pre>
<p>It is little more than putting things in the right place. Next we will use the
current <code>DetrendData</code> that we have, and use it to determine what the next
<code>DetrendData</code> should be. Because this depends on the new data and the parameter
\(\alpha\), we better accept them both.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn next(&amp;self, (time, brightness): (f64, f64), alpha: f64) -&gt; DetrendData {
    let trend = alpha * brightness + (1f64 - alpha) * self.trend;
    DetrendData {
        time: time,
        brightness: brightness,
        trend: trend,
        difference: brightness - trend,
    }
}
#}</code></pre></pre>
<p>We calculate the <code>trend</code> as described in the algorithm, and calculate the
difference from the brightness and the freshly calculated trend. With a
convenience method that turns the <code>DetrendData</code> into a <code>Vec&lt;String&gt;</code> we are
ready to calculate our entire trend.</p>
<p>We will collect our data in a vector of <code>DetrendData</code>. Because we are going to
incrementally add new entries to it, it needs to be mutable.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut sequence: Vec&lt;DetrendData&gt; = vec!();
#}</code></pre></pre>
<p>We also keep track of the last calculated <code>DetrendData</code> in a mutable variable
called <code>data</code>. Because we haven't calculated any value yet, its type is
<code>Option&lt;DetrendData&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut data: Option&lt;DetrendData&gt; = None
#}</code></pre></pre>
<p>This has the added benefit that we can differentiate between when to initialize
data, and when to calculate the next data, during our iteration over our raw data.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for candidate in raw {
    match data {
        None =&gt; {
            data = Some(DetrendData::initial(candidate))
        } 
        
        Some(previous) =&gt; {
            let next = previous.next(candidate, alpha);
            sequence.push(previous);
            data = Some(next)
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#further-considerations-4" id="further-considerations-4"><h2>Further Considerations</h2></a>
<p>How does the weighted detrend behave for known functions? Try to plot an step
function, i.e. a series that starts out 0 and than is 1 through out, and detrend
it.</p>
<p>What other kind of detrend strategies can you come up with?</p>
<a class="header" href="print.html#filter" id="filter"><h1>Filter</h1></a>
<p>Take a look the detrended brightness graph you made in the preceding chapter.</p>
<p><img src="image/detrend.png" alt="Detrended brightness of Trappist-1" /></p>
<p>There is a clear band of data. I.e. regions where most of the data-points lie.
But what also stands out enormous are
<a href="https://en.wikipedia.org/wiki/Outlier">outliers</a>. For example, most points are
below 50, but some shoot out all the way to 600. They are clearly
erroneous.</p>
<p>There are various reasons how these outliers can occur. Some are the results of
satellite maneuvers. What ever there origin, in this chapter we will filter
those outliers.</p>
<a class="header" href="print.html#processing-3" id="processing-3"><h2>Processing</h2></a>
<p>We are going to rely on our <code>data</code> function again. Remeber the <code>data</code> function
is responsible for:</p>
<blockquote>
<p>turning the raw columns of our CSV into <code>f64</code> values, and selecting the
correct ones.</p>
</blockquote>
<p>Now that we have our data, we can filter it in one swoop. <code>Iter</code> still has a
trick up it's sleeve. It sports a <code>filter</code> method that fits our needs. Study the
code below.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let result: Vec&lt;(f64, f64)&gt; = reader
    .map (|r| r.unwrap())
    .map(data)
    .filter(|&amp;(_,difference)| difference.abs() &lt;= threshold)
    .collect();
#}</code></pre></pre>
<p>The code above is depending on a threshold. Once chosen, the result can be written to a CSV file.</p>
<a class="header" href="print.html#further-considerations-5" id="further-considerations-5"><h2>Further Considerations</h2></a>
<p>The algorithm above depends on a certain threshold. What value should we use?
Try some different values and try to get a feel for what works. Discuss your
choices with somebody else.</p>
<a class="header" href="print.html#median" id="median"><h1>Median</h1></a>
<p>We filtered our brightness graph and got something like this.</p>
<p><img src="image/filter.png" alt="Filtered brightness of Trappist-1" /></p>
<p>We would like to know around what kind of average these points are fluctuating.
For that we are calculating the median.</p>
<a class="header" href="print.html#calculation" id="calculation"><h2>Calculation</h2></a>
<p>Let's say we have a sequence of values \(y_{0}, y_{1}, \ldots, y_{n-1}\). The
median of these numbers is defined as follows.</p>
<ol>
<li>Sort the numbers into a sequence \(z_{0}, z_{1}, \dots, z_{n-1}\).</li>
<li>From this sorted sequence, pick the middle number. If there is no middle,
take the average of the middle two.</li>
</ol>
<p>Lets work out an example. Take a look at the following example</p>
<p>\[
31, 41, 59, 26, 53, 58, 97, 93, 23, 84
\]</p>
<p>If we sort this sequence we get</p>
<p>\[
23, 26, 31, 41, 53, 58, 59, 84, 93, 97
\]</p>
<p>Because there are an even number of values, we should take the average of the of
the two middle values. The average of \(53\) and \(58\) is
\(\frac{53 + 58}{2} = \frac{111}{2} \approx 55.5\).</p>
<a class="header" href="print.html#make-a-library" id="make-a-library"><h2>Make a library.</h2></a>
<p>Because we are going to use the median several times, we are going to create a
library. Let's start with our <code>lib.rs</code>.</p>
<p>In our <code>lib.rs</code> we are announcing a module called <code>median</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod median;
#}</code></pre></pre>
<p>There are different ways to create this module. Either creating a <code>median.rs</code>
file inside the <code>src</code> directory. Or creating a <code>median</code> directory inside the
<code>src</code> directory, which contains a <code>mod.rs</code> file. Which every you choose, let's
implement a <code>median_of</code> function.</p>
<p>Our <code>median_of</code> function will have a <code>&amp;Vec&lt;f64&gt;</code> as parameter and return the
median <code>f64</code>. Once we have a sorted copy of the data called <code>copy</code>, getting the
median comes down to determining if the number of elements is even or odd, and
performing the right calculation.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let n = data.len();
let middle: usize = n / 2;
let median = if n % 2 == 1 {
    copy[middle]
} else {
    (copy[middle] + copy[middle - 1]) / 2.0;
}
#}</code></pre></pre>
<p>But how do we sort the original data?</p>
<a class="header" href="print.html#sorting-side-quest" id="sorting-side-quest"><h3>Sorting side-quest</h3></a>
<p>There are a few interesting tidbits when sorting a <code>Vec&lt;f64&gt;</code> that we are going
to make a side-quest out of it. While looking into <code>Vec&lt;T&gt;</code>
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.sort">documentation</a>,
you can come across the method <code>sort</code>. Let's see if we can use it.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut vs: Vec&lt;f64&gt; = vec!(3.0, 2.0, 1.0);

vs.sort();
#}</code></pre></pre>
<p>Unfortunately this doesn't compile.</p>
<pre><code class="language-text">   Compiling playground v0.0.1 (file:///playground)
error[E0277]: the trait bound `f64: std::cmp::Ord` is not satisfied
 --&gt; src/main.rs:6:4
  |
6 | vs.sort();
  |    ^^^^ the trait `std::cmp::Ord` is not implemented for `f64`

error: aborting due to previous error

error: Could not compile `playground`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Which could come as a surprise. The <code>Ord</code> trait determines an ordering of
elements. Certainly we can determine whether `0.0 &lt; 1.0``?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
assert!(0.0f64 &lt; 1.0f64);
#}</code></pre></pre>
<p>Luckily we can. So what is going on? Rust has two related traits for comparison:
<a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a> and
<a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>. The main difference
is that <code>Ord</code> is supposed to be <em>total</em>. I.e. any type that implements the <code>Ord</code>
trait should be able to compare any pair of values that have the type.</p>
<p>In other words, if you implement the <code>Ord</code> trait you should be able to answer
<strong>yes</strong> to one and only one of the following questions with for values <code>a</code> and
<code>b</code> in the type:</p>
<ol>
<li>Is <code>a &lt; b</code>?</li>
<li>Is <code>a == b</code>?</li>
<li>Is <code>a &gt; b</code>?</li>
</ol>
<p>The problem with <code>f64</code> is that is implements IEEE-754, the standard for
arithmetic with floating point numbers. This standard defines a value <code>NaN</code>,
not a number, which is not comparable with any other value.</p>
<p>So <code>f64</code> can not be complete and follow the standard at the same time.
Fortunately <code>PartialOrd</code> is implemented for <code>f64</code>. So as long as we do not
compare with <code>NaN</code>s, which we don't intend to do, we should be safe.</p>
<p>Back to sorting, the <code>sort</code> method expects that the <code>Ord</code> is implemented, so we
can not use it. <code>Vec&lt;T&gt;</code> also has a <code>sort_by</code> method, that allows to pass a <code>compare</code>
function. We can use this to our advantage by relying on the <code>PartialOrd</code> trait.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut vs: Vec&lt;f64&gt; = vec!(3.0, 2.0, 1.0);

vs.sort_by(|a, b| a.partial_cmp(b).unwrap());

println!(&quot;{:?}&quot;, vs);
#}</code></pre></pre>
<p>This correctly sorts our vector. But notice that the <code>vs</code> variable is declared
mutable. Our signature doesn't expect to have a mutable reference, so we need to
copy our <code>data</code> first.</p>
<a class="header" href="print.html#copying-data" id="copying-data"><h3>Copying Data</h3></a>
<p>We need a mutable copy of our <code>data</code>. Luckily the <code>Vec&lt;T&gt;</code> API provides an other
method; <code>copy_from_slice</code>. We use it as</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let n = data.len();
let mut copy = vec!(0f64; n);
copy.copy_from_slice(&amp;data);
#}</code></pre></pre>
<p>This is the final piece in the median puzzle. We are able to put everything
together and write our <code>median_of</code> function.</p>
<a class="header" href="print.html#form-groups" id="form-groups"><h3>Form Groups</h3></a>
<p>We do not want to calculate the median of our entire sequence. Instead we want
to move a <a href="https://en.wikipedia.org/wiki/Streaming_algorithm"><em>sliding window</em></a>
over our data and calculate the median of that specific window.</p>
<p>For that we need to group our data. Let's create that function.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn groups(data: &amp;Vec&lt;f64&gt;, group_size: usize) -&gt; Vec&lt;Vec&lt;f64&gt;&gt; {
    let mut groups: Vec&lt;Vec&lt;f64&gt;&gt; = vec!();

    for end_index in group_size .. data.len() + 1 {
        let mut group: Vec&lt;f64&gt; = vec!();
        for index in (end_index - group_size) .. end_index {
            group.push(data[index])
        }
        groups.push(group)
    }

    groups
}
#}</code></pre></pre>
<a class="header" href="print.html#median-filter" id="median-filter"><h3>Median Filter</h3></a>
<p>We are now in the position to create a <code>median_filter</code> function. I.e. a function
that calculates the median of a sliding window over our data. With all of our
preparations it writes itself as</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn median_filter(data: &amp;Vec&lt;f64&gt;, window: usize) -&gt; Vec&lt;f64&gt; {
    groups(data, window)
        .iter()
        .map(median_of)
        .collect()
}
#}</code></pre></pre>
<p>With our library all done, we can start out processing proper.</p>
<a class="header" href="print.html#processing-4" id="processing-4"><h2>Processing</h2></a>
<p>But wait! Our data arrives as <code>f64</code>-pairs, i.e. <code>(f64, f64)</code>, and we create
<code>median_filter</code> to operate on a single <code>f64</code> value. Did I lead you down a wrong
path?</p>
<p>Not entirely. Once again the standard library, in the form of the <code>Iter</code> trait,
has a trick up their sleeve. It comes in the pair of methods <code>zip</code> and <code>unzip</code>.
You can find their signatures below.
With <code>unzip</code> you can take a sequences of pairs and return a pair of sequences.
<code>zip</code> goes the other way.</p>
<p>Let's see how we can use them. After getting the raw data, we can use <code>unzip</code> to
extract the individual components.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let (times, values): (Vec&lt;f64&gt;, Vec&lt;f64&gt;) = raw
    .iter()
    .cloned()
    .unzip();
#}</code></pre></pre>
<p>The <code>cloned</code> call is because we need to take ownership of our data. Next we can
use our <code>median_filter</code> from our own library. Make sure to reference our own
external crate and import the correct function.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let median_times = median_filter(&amp;times, window_size);
let median_values = median_filter(&amp;values, window_size);
#}</code></pre></pre>
<p>Finally we can zip together these two vectors again to get our result.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let result = median_times.iter().zip(median_values);
#}</code></pre></pre>
<p>Storing this into a CSV file makes it available for the next step.</p>
<a class="header" href="print.html#further-considerations-6" id="further-considerations-6"><h2>Further Considerations</h2></a>
<p>You have created a library that contains some functions. How do you know that
they are implemented correctly? Try to add some
<a href="https://doc.rust-lang.org/book/second-edition/ch11-03-test-organization.html">tests</a>
that increases your confidence in your code.</p>
<p>The <code>median_filter</code> accepts an <code>window_size</code> argument. What is a good value?</p>
<p>Why haven't we used same the method we used to detrend the data?</p>
<a class="header" href="print.html#fitting" id="fitting"><h1>Fitting</h1></a>
<p>We have created a plot of the median.</p>
<p><img src="image/median.png" alt="The median of the filtered brightness" /></p>
<p>We would like to find planets in it. Finding planets amounts to selecting a
transit curve that nicely fits our data. We our going to divide that task in the
following sub-tasks.</p>
<ol>
<li>Generating a transit curve series</li>
<li>Iterating over all transit curve parameters</li>
<li>Scoring each candidate transit curve and selecting the best</li>
</ol>
<p>Let us create a module for this as well. We will call it <code>fit</code>.</p>
<a class="header" href="print.html#transit-curves" id="transit-curves"><h2>Transit Curves</h2></a>
<p><img src="image/period.png" alt="Multiple periods of a transit curves" /></p>
<p>The above image shows a typical transit curve where the planet transits the host
star multiple times. From this diagram we can learn about the parameters that
make up such a transit.</p>
<p>Below we list the parameters important in our transit curve.</p>
<ol>
<li><strong>Period</strong>. The time between the start of one transit and the start of the
next transit.</li>
<li><strong>Base</strong>. Height of the line, when no planet transits. This is often
normalized, but because of the choices we made, we need this parameter.</li>
<li><strong>Depth</strong>. How far the luminosity drops when the planets transits. This is
related to the size of the planet.</li>
<li><strong>Duration</strong>. How long the luminosity stays at full depth.</li>
<li><strong>Decay</strong>. How much time it takes the luminosity to go from the <code>base</code> to
<code>depth</code>. In our model the attack, i.e. time it takes the luminosity to go
from <code>depth</code> back to <code>base</code>, and decay are the same.</li>
<li><strong>Phase</strong>. Where in the period does the periodic function start.</li>
</ol>
<p>Below you find a <code>struct</code> and an implemented constructor that can track this
data.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Transit {
    period: f64,
    base: f64,
    depth: f64,
    duration: f64,
    decay: f64,
    phase: f64,
}

impl Transit {
    fn new((period, base, depth, duration, decay, phase): (f64,f64,f64,f64,f64,f64)) -&gt; Transit {
        Transit { period, base, depth, duration, decay, phase }
    }
}
#}</code></pre></pre>
<p>Notice that the <code>new</code> function accepts a tuple of floating point numbers. We
will use this when we iterate over the parameters.</p>
<p>What we also want to know is, when we have got a <code>time</code>, what is the
corresponding value of this transit curve. For that we are going to implement a
<code>value</code> method on `Transit</p>
<p>What we also want to know is, when we have got a <code>time, what is the corresponding value of this transit curve. For that we are going to implement a</code>value method on <code>Transit</code>.</p>
<p>The interesting times are</p>
<ol>
<li>Before the decay. The value should be <code>base</code></li>
<li>During the decay. The value should linearly interpolate between <code>base</code> and
<code>base</code> - <code>depth</code>.</li>
<li>During full transit. The value should be <code>base</code> - <code>depth</code></li>
<li>During the attack. The value should linearly interpolate between <code>base</code> -
<code>depth</code> and <code>base</code>.</li>
<li>After the transit. The value should be <code>base</code>.</li>
</ol>
<p>Implement the above logic into a <code>value</code> method for <code>Transit</code>.</p>
<a class="header" href="print.html#iterate-parameters" id="iterate-parameters"><h2>Iterate Parameters</h2></a>
<p>Our transit curve has five parameters. We would like to generate candidate
transit curves and check how well they fit our data. This can be accomplished by
iterating over the five parameters, and mapping them into a transit curve.</p>
<a class="header" href="print.html#floatiterator" id="floatiterator"><h3>FloatIterator</h3></a>
<p>We will first focus on an iterator for a single <code>f64</code>. We want all floating
point numbers between a <code>start</code> and <code>finish</code>, increasing each new number with a
certain <code>step</code>. We will create a <code>struct</code> that keeps track of where we are.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct FloatIterator {
    start: f64,
    finish: f64,
    step: f64,
    current: u64,
}
#}</code></pre></pre>
<p>Implementing a <code>new</code> constructor should set the <code>current</code> to <code>0</code> and accept
<code>start</code>, <code>finish</code> and step as parameters.</p>
<p>Next we need to implement <code>Iterator</code> for <code>FloatIterator</code>. We must import
<code>std::iter::Iterator</code> so that we can easily reference it in our code. In the
<code>next</code> method of the <code>Iterator</code> trait we need to decide if we need to return a
<code>Some</code> or a <code>None</code>. This depends on the our intended return value. I.e. if the
value <code>start + step * current</code> is less then or equal to our <code>finish</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Iterator for FloatIterator {
    type Item = f64;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let value = self.start + self.step * (self.current as f64);

        if value &lt;= self.finish {
            self.current += 1;

            Some(value)
        } else {
            None
        }
    }
}
#}</code></pre></pre>
<p>This wraps up our <code>FloatIterator</code>.</p>
<a class="header" href="print.html#exemplar-tupleiterator" id="exemplar-tupleiterator"><h3>Exemplar TupleIterator</h3></a>
<p>Next we are going to create a <code>TupleIterator</code>. It is going to show all the
necessary tools to create the actual <code>TupleIterator</code> we want, without getting
distracted by the tedious details.</p>
<p>Because we want to express multiple times a range of floating point numbers we
are interested in, we are going to create a <code>struct</code> to keep track of <code>start</code>,
<code>finish</code> and <code>step</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct FloatRange {
    start: f64,
    finish: f64,
    step: f64,
}
#}</code></pre></pre>
<p>implementing a <code>new</code> constructor for <code>FloatRange</code> is nothing more than excepting
the correct parameters and passing them in the struct. Having a <code>FloatRange</code>
allows us to ask it for the value belonging to a certain index. Let's extend the
implementation of <code>FloatRange</code> with an <code>index</code> function. The actual
implementation looks very familiar.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn index(&amp;self, index: u64) -&gt; Option&lt;f64&gt; {
    let value = self.start + self.step * (index as f64);

    if value &lt;= self.finish {
        Some(value)
    } else {
        None
    }
}
#}</code></pre></pre>
<p>Now that we can express the floating point range we are interested in, we can
use that in our <code>TupleIterator</code>. The responsibility of the <code>TupleIterator</code> is to
keep track of two indices into two separate <code>FloatIterator</code>. Because we need to
be able to &quot;restart&quot; the <code>FloatIterator</code> we are not actually use a
<code>FloatIterator</code>. Instead we choose to do the iterating our selves.</p>
<p>We start with a structure that will keep track for us.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct TupleIterator {
    first: FloatRange,
    second: FloatRange,
    current: (u64, u64),
}
#}</code></pre></pre>
<p>It looks a lot like the <code>FloatIterator</code>. The main difference is that we need to
keep track of two different ranges, and two different indices into these
iterators. Implementing a new is just like the <code>FloatIterator</code> little more than
accepting the correct parameters and initializing the current indices to
<code>(0,0)</code>.</p>
<p>Now for implementing <code>Iterator</code> for <code>TupleIterator</code>. It comes down to keeping
track of the right indices. Let's look at the implementation.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Iterator for TupleIterator {
    type Item = (f64, f64);

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let (first_index, second_index) = self.current;

        match self.first.index(first_index) {
            Some(first_value) =&gt; {
                match self.second.index(second_index) {
                    Some(second_value) =&gt; {
                        self.current = (first_index, second_index + 1);

                        Some((first_value, second_value))
                    },

                    None =&gt; {
                        self.current = (first_index + 1, 0);

                        self.next()
                    },
                }
            },

            None =&gt; None,
        }
    }
}
#}</code></pre></pre>
<p>Reading the code, we discover that we determine two values, one for each
<code>FloatRange</code>. If the first <code>FloatRange</code> return <code>None</code> we are done. If it returns
some value, we see what the second <code>FloatRange</code> returns. If that also returns
some value, we do the following things.</p>
<ol>
<li>Increment the second index.</li>
<li>Return the tuple of values.</li>
</ol>
<p>If the second <code>FloatRange</code> doesn't return some value, we know that it exhausted
its range. We then increment the first index, resetting the second index. In
effect we want to the second iterator from scratch, but with a new first value.
Next we use the power of recursion to determine what the value should be with
the new indices.</p>
<p>Although it doesn't look pretty, it does its job. It is your task to extend this
example to iterate over all transit parameters.</p>
<a class="header" href="print.html#score" id="score"><h2>Score</h2></a>
<p>We are going to score a <code>Transit</code> with the
<a href="https://en.wikipedia.org/wiki/Least_squares"><em>least squares</em></a> method. This
method sums the squares of the difference between two series. That is easier
said than done. Lets look at following code.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn least_squares(xs: &amp;Vec&lt;f64&gt;, ys: &amp;Vec&lt;f64&gt;) -&gt; f64 {
    xs.iter().zip(ys)
        .map(|(a,b)| (a-b).powi(2))
        .sum()
}
#}</code></pre></pre>
<p>We define a function names <code>least_squares</code> that accepts to vectors of floating
points numbers. Next we recognize our dear friend: the <code>iter</code> method. We use it
on the first vector and zip it with the second vector. On the vector of pairs we
map the function that calculates the squared difference. We finish with summing
all the numbers, getting our result.</p>
<p>With all the parts in place we are ready to start processing.</p>
<a class="header" href="print.html#processing-5" id="processing-5"><h2>Processing</h2></a>
<p>We need to compare candidate transit curves with our median, so we need to read our <code>median.csv</code>. Because we would like to process the times and the values separedly we use the <code>unzip</code> trick we learned earlier.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let (times, values): (Vec&lt;f64&gt;, Vec&lt;f64&gt;) = raw
    .iter()
    .cloned()
    .unzip();
#}</code></pre></pre>
<p>Processing consist for a big part of a main loop that iterates over our transit parameters. This is depend on a number of <code>FloatRange</code>s and this is where you can shine. By looking at your <code>median.csv</code> data you can guess good ranges, and with some luck you will find planets.</p>
<p>We need to keep track of the best transit curve. So we initialize variables before our main loop.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut best_score = f64::MAX;
let mut best_transit: Option&lt;Transit&gt; = None;
#}</code></pre></pre>
<p>In order to make use of the <code>f64::MAX</code> we need to import <code>std::f64</code>. Not that the best score will actually be the lowest value, so it is save to initialize it to the maximum value.</p>
<p>Inside our loop, we can create a transit curve from the parameters.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let transit = Transit::new(parameters);
#}</code></pre></pre>
<p>The <code>transit</code> can be used to determine the values at the times we observed by mapping over the <code>times</code> and using the <code>value</code> method.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let transit_values: Vec&lt;f64&gt; = times.iter().map(|t| transit.value(t)).collect();
#}</code></pre></pre>
<p>Scoring is little more than calling the right function.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let score = least_squares(&amp;transit_values, &amp;values);
#}</code></pre></pre>
<p>Now that we have the score, we need to compare it with the best score we now about, and update our best candidate accordingly.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
if score &lt; best_score {
    best_score = score;
    best_transit = Some(transit.clone());
}
#}</code></pre></pre>
<p>When the loop finishes we would like to know which transit is the best. So we prepare to print it to console, and calculate the actual values, which you can write to a CSV file.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let best_transit = best_transit.unwrap();
let best_transit_values: Vec&lt;f64&gt; = times.iter().map(|t| best_transit.value(t)).collect();
println!(&quot;{:?}&quot;, best_transit);

let result = times.iter().zip(best_transit_values);
#}</code></pre></pre>
<p>Lets fly through our candidates and see what planet you can find.</p>
<a class="header" href="print.html#further-considerations-7" id="further-considerations-7"><h2>Further Considerations</h2></a>
<p>How do you know that you implemented the various libraries correctly? Have you tested them?</p>
<p>The way that we generate our transit parameters is going through all possible values. This seems a bit wastefull. Can you come up with a better way? Discussing your thoughts with somebody.</p>
<p>We used the method of least squares to score a transit curve. What other scoring mechanism can you think of. What difference would it make?</p>
<a class="header" href="print.html#javascript-1" id="javascript-1"><h1>JavaScript</h1></a>
<p>This is the start of an exciting scientific journey where we will use
<a href="https://www.javascript.com/">JavaScript</a> as our tool to find planets around
Trappist-1.</p>
<a class="header" href="print.html#fits-1" id="fits-1"><h1>FITS</h1></a>
<p>The results of the NASA Kepler mission on observing Trappist-1 are
<a href="https://keplerscience.arc.nasa.gov/raw-data-for-k2-campaign-12-and-trappist-1-now-available.html">available</a>
to the public. For your ease of use we downloaded the FITS files before hand.</p>
<a class="header" href="print.html#what-are-fits-files-1" id="what-are-fits-files-1"><h2>What are FITS files</h2></a>
<p>A <a href="https://en.wikipedia.org/wiki/FITS">FITS</a> file is a</p>
<blockquote>
<p>open standard defining a digital file format useful for storage,
transmission and processing of scientific and other images. FITS is the most
commonly used digital file format in astronomy. Unlike many image formats,
FITS is designed specifically for scientific data and hence includes many
provisions for describing photometric and spatial calibration information,
together with image origin metadata.</p>
</blockquote>
<p>We would like to use the FITS files directly, but unfortunately the
<a href="https://github.com/itpmngt/FITS">library</a> is not production ready yet. We
created a Comma Seperated Values (CSV) file with the relevant data.</p>
<a class="header" href="print.html#csv-1" id="csv-1"><h1>CSV</h1></a>
<p>Comma Seperated values play an integral role in this workshop. We don't need an
particular sharp tool to process CSV files. Basic reading and writing is more
than enough. We are going to use the <code>csv</code> package for this.</p>
<p>Whenever we use the functionality we are going to explain what we are doing. If
you want a head start take a look at the
<a href="http://csv.adaltas.com/parse/examples/">documentation</a>.</p>
<a class="header" href="print.html#image-1" id="image-1"><h1>Image</h1></a>
<p>Now that we have our data in a CSV file, we are operating on it. The first thing
that we should do is make an image.</p>
<a class="header" href="print.html#artist-impression-1" id="artist-impression-1"><h2>Artist Impression</h2></a>
<p><img src="image/artist-impression.jpg" alt="An artist impression of Trappist-1" /></p>
<p>Often artists are commissioned to create a stunning visualization of new findings.
This is also the case with the Trappist-1 news. Above you find an artist
impression of Trappist-1.</p>
<p>The downside of this is that we could loose track of the actual data that is
used. In order to get a sense of awe for the search of exo-planets, we are
creating our own impression.</p>
<a class="header" href="print.html#creating-an-image-1" id="creating-an-image-1"><h2>Creating an image</h2></a>
<p>So go ahead and start a new JavaScript file named <code>image.js</code> in the <code>bin</code>
directory of your project.</p>
<a class="header" href="print.html#reading-data-1" id="reading-data-1"><h3>Reading Data</h3></a>
<p>We will be reading our data from CSV. We will use the <code>csv</code> packege for
that. In order to use it include the following lines in <code>image.js</code>.</p>
<pre><code class="language-javascript">const parse = require('csv-parse');
const stringify = require('csv-stringify');
const transform = require('stream-transform');

var parser = parse();
var stringifier = stringify();
var transformer = transform(function(data){
    return data;
});
</code></pre>
<p>The <code>parser</code>, <code>transformer</code> and <code>stringifier</code> can be piped together. So we need
something to act as a source and a drain. We are going to read from file and
write to file so we include de <code>fs</code> module.</p>
<pre><code class="language-javascript">const fs = require('fs');
</code></pre>
<p>And in the script we add.</p>
<pre><code class="language-javascript">var input = fs.createReadStream('../long-cadence.csv');
var output = fs.createWriteStream('out.csv');
</code></pre>
<p>Notice that we are not handling errors in a graceful way. We are just going to
arrange everything correctly and hope for the best.</p>
<p>We now can pipe the input, via our chain into the output.</p>
<pre><code class="language-javascript">input
    .pipe(parser)
    .pipe(transformer)
    .pipe(stringifier)
    .pipe(output);
</code></pre>
<p>This is our processing pipeline. You will probably use it for a lot, so make
sure that you understand what is going on. If you run it, nothing really
interesting is going on. Basically we just copied the original data. Let's
change that.</p>
<a class="header" href="print.html#processing-data-1" id="processing-data-1"><h3>Processing Data</h3></a>
<p>The transformer can be used to change the data but we are not going to do that
just now. Instead we want to operate on each row that gets piped through our
pipeline.</p>
<p>We can do that with the following lines of code.</p>
<pre><code class="language-javascript">transformer.on('readable', function(){
    var row;
    while (row = transformer.read()) {
        // process a row
    }
});

</code></pre>
<p>Our CSV file contains rows of floating point numbers. The first value is the
time of the recording and the rest are image values, one for each pixel of a
11x11 image.</p>
<p>So inside the transformer while loop, i.e. where we process a row, we are going
to create a PNG file. Before we can do that we need to require the <code>node-png</code>
module.</p>
<pre><code class="language-javascript">const PNG = require('node-png').PNG;
</code></pre>
<p>Creating the PNG file by calling the constructor with the correct options.</p>
<pre><code class="language-javascript">var png = new PNG({
    width: 11,
    height: 11,
    filter: -1
});
</code></pre>
<p>Now we are ready to process our row. What we are going to do is map these
measurements onto a gray scale that we can save as an image. We do this by
determining the maximum measurement, determining the relative measurement
compared to the maximum, and scaling it the an integer range from 0 to 255.</p>
<pre><code class="language-javascript">var data = row.slice(1);
var max = Math.max(...data);
data.forEach(function(value, index){
    var gray = value/max * 255;
    png.data[4*index + 0] = gray;
    png.data[4*index + 1] = gray;
    png.data[4*index + 2] = gray;
    png.data[4*index + 3] = 0xff;
});
</code></pre>
<p>Finally, we write our image.</p>
<pre><code class="language-javascript">png.pack().pipe(fs.createWriteStream('out.png'));
</code></pre>
<a class="header" href="print.html#our-image-1" id="our-image-1"><h2>Our Image</h2></a>
<p>It is finally time to make our own impression of Trappist-1. Use <code>node</code> to run
your code.</p>
<pre><code class="language-shell">&gt; node bin/image.js
</code></pre>
<p>Which creates</p>
<p><img src="image/trappist-1.0.png" alt="Actual Trappist-1 photo" /></p>
<a class="header" href="print.html#appreciate-the-image-1" id="appreciate-the-image-1"><h2>Appreciate the Image</h2></a>
<p>At first glance the image can be a little underwhelming. But it is precisely
this image that blew my mind! Being accustomed to the marvelous artist
impression, when I learned about the actual data was 11x11 pixels I was hooked.
How could anyone extract so much information from so little data?</p>
<p><img src="image/trappist-1.0.large.png" alt="10 times enlargement of actual Trappist-1 photo" /></p>
<p>I had to know and I hope you want to know too!</p>
<a class="header" href="print.html#further-considerations-8" id="further-considerations-8"><h2>Further Considerations</h2></a>
<ul>
<li>Make a bigger image with larger &quot;pixels&quot;.</li>
<li>Make an entire series of images, one for each row.</li>
<li>Make a GIF or movie of the images.</li>
</ul>
<a class="header" href="print.html#collage-1" id="collage-1"><h1>Collage</h1></a>
<p>In this chapter we will create a Collage of all the image in the long cadence
file. Although it is a bit of a side-track, we will learn valuable things by
looking at the image.</p>
<p>If you want, you can take a <a href="image/collage.png">sneak peek</a>.</p>
<p>We will not go into details of reading the data and writing the transformed
data. We assume that the previous chapters have given enough examples to learn
from. Instead we are going to focus on processing the data.</p>
<a class="header" href="print.html#processing-6" id="processing-6"><h2>Processing</h2></a>
<p>There are a few questions we need to answer before we can create our collage.</p>
<ol>
<li>For a row of data and a column in that row, which pixel should we paint?</li>
<li>What color should we paint that pixel?</li>
</ol>
<a class="header" href="print.html#position-1" id="position-1"><h3>Position</h3></a>
<p>When we created the single image, we did not have to think about positioning
explicitly. Because we want to make a collage we have some work to do.</p>
<p>First of all, lets state some facts.</p>
<ol>
<li>Each image is 11x11 pixels.</li>
<li>There are 3599 rows of images.</li>
</ol>
<p>The interesting thing about 3599 is that is 61x59. So we could make our collage
almost a square with 61 columns and 59 rows of single images. With 11x11 images
as base our collage will come in at 61x11 = 671 by 59x11 = 649.</p>
<p>Let's start by giving names to things. We start out with the tile base size,
i.e. the size of the original image. We are going to call that <code>BASE</code>. Next we
want 61 of our tiles to go horizontally, and we want 59 of our tiles to go
vertically. We will call these <code>HORIZONTAL_TILES</code> and <code>VERTICAL_TILES</code>
respectively.</p>
<pre><code class="language-javascript">const BASE = 11;
const HORIZONTAL_TILES = 61;
const VERTICAL_TILES = 59;
</code></pre>
<p>Now we can express all the other dimensions in terms of our <code>BASE</code> and
<code>HORIZONTAL_TILES</code> and <code>VERTICAL_TILES</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const WIDTH = HORIZONTAL_TILES * BASE;
const HEIGHT = VERTICAL_TILES * BASE;
const SIZE = WIDTH * HEIGHT;
#}</code></pre></pre>
<p>For example, <code>SIZE</code> is the number of pixels in our base tile. Let's continue and
figure out where the pixels go. There are two factors that determine the
position of the pixel. The which row that data is from, and which column the
data is in.</p>
<p>We will start with the row. Because we have 61 images along the x-axis of our
collage, the <code>X</code>-offset will be</p>
<pre><code class="language-javascript">var offset_X = row_index % HORIZONTAL_TILES;
</code></pre>
<p>We keep track of the <code>row_index</code> manually.</p>
<p>After <code>HORIZONAL_TILES</code> rows, we need to increase the <code>Y</code>-offset with one. This amounts to</p>
<pre><code class="language-javascript">var offset_Y = Math.floor(row_index / HORIZONTAL_TILES);
</code></pre>
<p>Now for the offset within the image. The image is <code>BASE</code>x<code>BASE</code>. So given an original
index in the row, we have for the</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
var offset_x = original_index % BASE;
var offset_y = Math.floor(original_index / BASE);
#}</code></pre></pre>
<p>Now we can calculate the target index. For each <code>offset_Y</code> we need to go down an
entire <code>BASE</code> rows in our collage. This is <code>BASE</code>x<code>HORIZONTAL_TILES</code>x<code>BASE</code> (=
7381). For each <code>offset_X</code> we need to shift <code>BASE</code> pixels down. For each
<code>offset_y</code> we need to go down an entire row. This is <code>HORIZONTAL_TILES</code>x<code>BASE</code>
(= 671). Finally, for each <code>offset_x</code> we need to shift 1 pixel
down. All together this is</p>
<pre><code class="language-javascript">var target_index = offset_Y * (BASE * HORIZONTAL_TILES * BASE) +
                   offset_X * BASE +
                   offset_y * (HORIZONTAL_TILES * BASE) +
                   offset_x;
</code></pre>
<p>With these calculations we know where to paint the image pixel.</p>
<a class="header" href="print.html#color-1" id="color-1"><h3>Color</h3></a>
<p>From our experience from creating an image we have a fairly good idea which
color to use. The only difference between the collage and the single image is
that we want to use the same scale for each image.</p>
<p>So instead of dividing our value by the maximum value of a single image, we
should divide by the global maximum.</p>
<p>Create a separate script that will determine the global maximum of all the
measurements that we can use in determining the color of the pixel.</p>
<a class="header" href="print.html#further-considerations-9" id="further-considerations-9"><h2>Further Considerations</h2></a>
<p>The following suggestions might help your understanding of the problem we
facing, i.e. detecting planets in our image.</p>
<p>Take a long good look at your collage. Write down what you notice about the
image. Ask yourself some questions and discuss your observations with somebody
else.</p>
<p>Why do we need a global maximum? What would happen if we would stick to the
maximum per image? What would that look like, and what would it tell you?</p>
<a class="header" href="print.html#brightness-1" id="brightness-1"><h1>Brightness</h1></a>
<p>We are going to detect the planets by observing drops in overall brightness.
Before we are able to do this, we need to calculate the brightness. That is
precisely the objective in this chapter.</p>
<p>We are going to create a CSV file with the first column the time of the
measurement and the second column the brightness at that time.</p>
<a class="header" href="print.html#processing-7" id="processing-7"><h2>Processing</h2></a>
<p>For each row of data we would like to know how much Trappist-1 is radiating.
What we are going to do is the following.</p>
<p>Take a row of data and sum all the values to get the overall brightness.</p>
<p>the first thing that we need to do is transform our data in to floating point
numbers. When our <code>csv</code> module reads in a row of data, it is a piece of text.
The
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><code>map</code></a>
function helps in this regard.</p>
<pre><code class="language-javascript">brightness
    .map(function(values){ return parseFloat(values; )})
</code></pre>
<p>The summation of all the values can be written down very succinctly because the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype"><code>Array</code></a>
prototype has a trick up it's sleeve. The <code>Array.prototype</code> has a <code>reduce</code> method. We
can use it to calculate the sum of all the brightness values. If we have our values
in the variable <code>brightness</code>, we can determine the sum with</p>
<pre><code class="language-javascript">const sum = brightness
    .map(function(values){ return parseFloat(values; )})
    .reduce(function(partial_sum, value){
        return partial_sum + value;
    }, 0);
</code></pre>
<a class="header" href="print.html#removing-background-1" id="removing-background-1"><h3>Removing Background</h3></a>
<p>If we take a look at one of the images</p>
<p><img src="image/trappist-1.0.large.png" alt="Enlargement of an image of Trappist-1" /></p>
<p>we see that the background is not pitch black. This means that the background
adds to the brightness, even though it does not contribute to the signal. So we
start our journey with something we will come very familiar with, we will clean
up our data.</p>
<p>What we are going to do is ignore the brightness value of anything below the
average brightness. This transforms the image from above into the image below.</p>
<p><img src="image/trappist-1.0.nobg.large.png" alt="Enlargement of an image of Trappist-1 with background removed" /></p>
<p>Still not perfect, but it is better than nothing.</p>
<p>In order to filter out the unwanted background we are going to need to know the
average. We already know the sum, we just calculated it, so the average can be
determined by</p>
<pre><code class="language-javascript">const average = sum / brightness.length;
</code></pre>
<p>Calculating the contribution of the values above the average can still be done
succinctly. What we need to do is filter out the values that we want to sum.
I.e. the values above the average.</p>
<pre><code class="language-javascript">const filtered_sum_= brightness
    .filter(function(value){ return value &gt;= average; })
    .reduce(function(partial_sum, value){ return partial_sum + value; }, 0);
</code></pre>
<p>What we want to return in our transformer is the pair of the <code>time</code>, we is the
first value of our row of data i.e. <code>const time = data[0]</code>, and our
<code>filtered_sum</code>.</p>
<pre><code class="language-javascript">return [time, filtered_sum];
</code></pre>
<a class="header" href="print.html#graphing-results-1" id="graphing-results-1"><h2>Graphing Results</h2></a>
<p>Once you wrote your brightness results to a CSV file, they are ready for the
following step. But if you are like me you probably want to see your results.
This is where gnuplot comes in.</p>
<p>If you have saved your results as <code>brightness.csv</code>, the following gnuplot
session will plot your data.</p>
<pre><code>set datafile separator ','

plot [2905:2985] &quot;brightness.csv&quot; using 1:2
</code></pre>
<p>We will annotate the above example a little, so that you can use gnuplot on your
own. The <code>simple_csv</code> library outputs CSV files with a comma as separator. This
difference from the default assumption of gnuplot. Luckily this can be remedied
with the first line.</p>
<p>The second line display the core of gnuplot; the <code>plot</code> command. The first
argument, i.e. <code>[2905:2985]</code>, defines the range on the x-axis. It is optional
and will be inferred by gnuplot if it isn't present. If there would be a second
argument of that form, i.e. <code>[min:max]</code>, that would be the range on the y-axis.
Here it is inferred.</p>
<p>The <code>&quot;brightness.csv&quot;</code> argument you probably recognize as the file you wrote
your data to. The <code>plot</code> command will use data in this file to plot.</p>
<p>The last refers to columns in the data. <code>using 1:2</code> tells the plot command to
plot point with the first column as x-coordinate and the second column as
y-coordinate.</p>
<p>For a more extensive explanation of gnuplot we refer you to the
<a href="http://www.gnuplot.info/">gnuplot homepage</a>.</p>
<p>If you have gone to the trouble of outputting the brightness with and without
the background, your plot could look like the one below.</p>
<p><img src="image/brightness-both.png" alt="Plot of brightness, with and without background contribution" /></p>
<a class="header" href="print.html#further-considerations-10" id="further-considerations-10"><h2>Further Considerations</h2></a>
<p>Take a look at your data and write down what stands out to you. Discuss this
with a neighbor.</p>
<p>Why is the average taken as a cut-off value? What are other options?</p>
<p>There is an obvious gap in our data. This is where the Kepler satellite stopped
recording data due to a software reboot initiated by a cosmic ray event.
Although the data was lost, the satellite still operates nominally.</p>
<p>Furthermore there is a trend in the overall brightness, more pronounced in the
data with the background. This is also seen in our collage. We will have to
smooth out that trend and that is precisely what we will in one of the next chapters.</p>
<a class="header" href="print.html#detrend-1" id="detrend-1"><h1>Detrend</h1></a>
<p>Take a look the brightness graph you made in the preceding chapter.</p>
<p><img src="image/brightness-nobackground.png" alt="Brightness of Trappist-1" /></p>
<p>Notice how the graph tends to flare up. This is a systemic problem that we
should correct. We are going to do that by finding what trend the graph is
following, and adjusting for that.</p>
<a class="header" href="print.html#processing-8" id="processing-8"><h2>Processing</h2></a>
<p>Before, we processed each row individually. Now we need to operate on the entire
sequence. So instead iterating over each row, we are going to transform it
directly.</p>
<p>Our data has two values, one for time and one for the brightness. We our
responsible for turning the raw columns of our CSV into floating point values,
perform our calculation and selecting the correct ones.</p>
<p>Up until now we never returned more than two or three values. For our current
plan we are going to return more. In order to keep track of our data, we are
going to create a datastructure.</p>
<pre><code class="language-javascript">var detrend_data {
    time: 0.0,
    brightness: 0.0,
    trend: 0.0,
    difference: 0.0,
}
</code></pre>
<p>We have created a few entries, some familiar, some unfamiliar. <code>time</code> and
<code>brightness</code> are pretty self-explanatory. <code>difference</code> is intended to hold the
difference between the <code>brightness</code> and the <code>trend</code>.</p>
<p>But how do we calculate the trend?</p>
<a class="header" href="print.html#strategies-1" id="strategies-1"><h3>Strategies</h3></a>
<p>Let us reflect on what we are trying to achieve. We have some data points
\(y_{0}, y_{1}, \ldots, y_{n}\). We have a model that predicts that these
values fluctuate around a given mean \(Y\), but for some reason or another, it
doesn't.</p>
<p>Instead the values fluctuate around some function \(f\), for which we don't
now the shape or form. This is called the <em>trend</em>.</p>
<p>Our goal is to approximate the trend function \(f\) by a function that we can
calculate from the data. Next we can analyze the actual signal by removing the
trend. In effect we will look at the de-trended signal \(y_{0} - t(0), y_{1} -
t(1), \ldots, y_{n} - t(n)\). Here \(t\) is our approximation for the trend.</p>
<p>We shall do this by providing the values of our approximation.</p>
<p>There are numerous strategies for determining the trend in a sequence of data.
Below you can find a strategy we have selected for this workshop.</p>
<a class="header" href="print.html#weighted-trend-1" id="weighted-trend-1"><h4>Weighted Trend</h4></a>
<p>With the notations from the preceding section the weighted trend algorithm is as
follows. First you pick a parameter \(\alpha\) such that it lies between zero
and one, i.e. \(0 \le \alpha \le 1\).</p>
<p>Next we will explain how to calculate each point of our approximation to the
trend.</p>
<ul>
<li>\(t_{0} = y_{0}\). I.e. our first approximation is the first value of our
sequence of data.</li>
<li>\(t_{i} = \alpha y_{i} + (1-\alpha) t_{i-1}\). I.e. our trend tends towards
the new value of our sequence, but is a but reluctant. It tends to stick to
the previous values.</li>
</ul>
<p>Let's implement this algorithm. With our <code>detrend_data</code> structure, we have an
opportunity to directly implement the different branches of our algorithm. Since
our data gets delivered to us in as a pair of floating point values, we better accept it as
an argument in our transformer and pick the pair apart.</p>
<pre><code class="language-javascript">const time = parseFloat(data[0]);
const brightness = parseFloat(data[1]);
</code></pre>
<p>It is little more than giving things in the name. Next we will use the
previous <code>detrend_data</code> that we have, and use it to determine what the next
<code>detrend_data</code> should be. Because this depends on the new data and the parameter
\(\alpha\), we better use them both.</p>
<pre><code class="language-javascript">const trend = alpha * brightness + (1 - alpha) * previous_detrend_data.trend;
const difference = brightness - trend;
detrend_data = {
    'time': time,
    'brightness': brightness,
    'trend': trend,
    'difference': difference
};
</code></pre>
<p>We calculate the <code>trend</code> as described in the algorithm, and calculate the
difference from the brightness and the freshly calculated trend.</p>
<p>But where does the <code>previous_detrend_data</code> come from? We initialize it outside
the transformer to <code>undefined</code>, and check if we processed a
<code>previous_detrend_data</code> or that we need to initialize it</p>
<pre><code class="language-javascript">var detrend_data;
if (previous_detrend_data) {
    /* calculate the detrend_data  */
} else {
    /* initialize detrend_data */
}
previous_detrend_data = detrend_data;
</code></pre>
<p>We initialize the <code>detrend_data</code> by assign sane values to it.</p>
<pre><code class="language-javascript">detrend_data = {
    'time': time,
    'brightness': brightness,
    'trend': brightness,
    'difference': 0
};
</code></pre>
<p>In either way, we set the <code>previous_detrend_data</code> to our current <code>detrend_data</code>
so that it is ready for the next row.</p>
<p>Now that we have our data, we can let our csv pipeline process it. We only need
to return an array of the data we are interested in.</p>
<pre><code class="language-javascript">return [
    detrend_data.time, 
    detrend_data.brightness, 
    detrend_data.trend, 
    detrend_data.difference
];
</code></pre>
<a class="header" href="print.html#further-considerations-11" id="further-considerations-11"><h2>Further Considerations</h2></a>
<p>How does the weighted detrend behave for known functions? Try to plot an step
function, i.e. a series that starts out 0 and than is 1 through out, and detrend
it.</p>
<p>What other kind of detrend strategies can you come up with?</p>
<a class="header" href="print.html#filter-1" id="filter-1"><h1>Filter</h1></a>
<p>Take a look the detrended brightness graph you made in the preceding chapter.</p>
<p><img src="image/detrend.png" alt="Detrended brightness of Trappist-1" /></p>
<p>There is a clear band of data. I.e. regions where most of the data-points lie.
But what also stands out enormous are
<a href="https://en.wikipedia.org/wiki/Outlier">outliers</a>. For example, most points are
below 50, but some shoot out all the way to 600. They are clearly
erroneous.</p>
<p>There are various reasons how these outliers can occur. Some are the results of
satellite maneuvers. What ever there origin, in this chapter we will filter
those outliers.</p>
<a class="header" href="print.html#processing-9" id="processing-9"><h2>Processing</h2></a>
<p>We are defining a threshold beyond which we will discard our data.</p>
<pre><code class="language-javascript">const threshold = 200.00;
</code></pre>
<p>Next we will use that threshold to in our data to discard our actual data.
Discarding can be achieved by return <code>null</code> instead of an array of data.</p>
<pre><code class="language-javascript">const time = parseFloat(data[0]);
const brightness = parseFloat(data[1]);
const trend = parseFloat(data[2]);
const difference = parseFloat(data[3]);

if (Math.abs(difference) &lt;= threshold) {
    return data;
} else {
    return null;
}
</code></pre>
<a class="header" href="print.html#further-considerations-12" id="further-considerations-12"><h2>Further Considerations</h2></a>
<p>The algorithm above depends on a certain threshold. What value should we use?
Try some different values and try to get a feel for what works. Discuss your
choices with somebody else.</p>
<a class="header" href="print.html#median-1" id="median-1"><h1>Median</h1></a>
<p>We filtered our brightness graph and got something like this.</p>
<p><img src="image/filter.png" alt="Filtered brightness of Trappist-1" /></p>
<p>We would like to know around what kind of average these points are fluctuating.
For that we are calculating the median.</p>
<a class="header" href="print.html#calculation-1" id="calculation-1"><h2>Calculation</h2></a>
<p>Let's say we have a sequence of values \(y_{0}, y_{1}, \ldots, y_{n-1}\). The
median of these numbers is defined as follows.</p>
<ol>
<li>Sort the numbers into a sequence \(z_{0}, z_{1}, \dots, z_{n-1}\).</li>
<li>From this sorted sequence, pick the middle number. If there is no middle,
take the average of the middle two.</li>
</ol>
<p>Lets work out an example. Take a look at the following example</p>
<p>\[
31, 41, 59, 26, 53, 58, 97, 93, 23, 84
\]</p>
<p>If we sort this sequence we get</p>
<p>\[
23, 26, 31, 41, 53, 58, 59, 84, 93, 97
\]</p>
<p>Because there are an even number of values, we should take the average of the of
the two middle values. The average of \(53\) and \(58\) is
\(\frac{53 + 58}{2} = \frac{111}{2} \approx 55.5\).</p>
<a class="header" href="print.html#make-a-library-1" id="make-a-library-1"><h2>Make a library.</h2></a>
<p>Because we are going to use the median several times, we are going to create a
library. Let's start with our <code>lib.rs</code>.</p>
<p>In our <code>lib.rs</code> we are announcing a module called <code>median</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod median;
#}</code></pre></pre>
<p>There are different ways to create this module. Either creating a <code>median.rs</code>
file inside the <code>src</code> directory. Or creating a <code>median</code> directory inside the
<code>src</code> directory, which contains a <code>mod.rs</code> file. Which every you choose, let's
implement a <code>median_of</code> function.</p>
<p>Our <code>median_of</code> function will have a <code>&amp;Vec&lt;f64&gt;</code> as parameter and return the
median <code>f64</code>. Once we have a sorted copy of the data called <code>copy</code>, getting the
median comes down to determining if the number of elements is even or odd, and
performing the right calculation.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let n = data.len();
let middle: usize = n / 2;
let median = if n % 2 == 1 {
    copy[middle]
} else {
    (copy[middle] + copy[middle - 1]) / 2.0;
}
#}</code></pre></pre>
<p>But how do we sort the original data?</p>
<a class="header" href="print.html#sorting-side-quest-1" id="sorting-side-quest-1"><h3>Sorting side-quest</h3></a>
<p>There are a few interesting tidbits when sorting a <code>Vec&lt;f64&gt;</code> that we are going
to make a side-quest out of it. While looking into <code>Vec&lt;T&gt;</code>
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.sort">documentation</a>,
you can come across the method <code>sort</code>. Let's see if we can use it.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut vs: Vec&lt;f64&gt; = vec!(3.0, 2.0, 1.0);

vs.sort();
#}</code></pre></pre>
<p>Unfortunately this doesn't compile.</p>
<pre><code class="language-text">   Compiling playground v0.0.1 (file:///playground)
error[E0277]: the trait bound `f64: std::cmp::Ord` is not satisfied
 --&gt; src/main.rs:6:4
  |
6 | vs.sort();
  |    ^^^^ the trait `std::cmp::Ord` is not implemented for `f64`

error: aborting due to previous error

error: Could not compile `playground`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Which could come as a surprise. The <code>Ord</code> trait determines an ordering of
elements. Certainly we can determine whether `0.0 &lt; 1.0``?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
assert!(0.0f64 &lt; 1.0f64);
#}</code></pre></pre>
<p>Luckily we can. So what is going on? Rust has two related traits for comparison:
<a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a> and
<a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>. The main difference
is that <code>Ord</code> is supposed to be <em>total</em>. I.e. any type that implements the <code>Ord</code>
trait should be able to compare any pair of values that have the type.</p>
<p>In other words, if you implement the <code>Ord</code> trait you should be able to answer
<strong>yes</strong> to one and only one of the following questions with for values <code>a</code> and
<code>b</code> in the type:</p>
<ol>
<li>Is <code>a &lt; b</code>?</li>
<li>Is <code>a == b</code>?</li>
<li>Is <code>a &gt; b</code>?</li>
</ol>
<p>The problem with <code>f64</code> is that is implements IEEE-754, the standard for
arithmetic with floating point numbers. This standard defines a value <code>NaN</code>,
not a number, which is not comparable with any other value.</p>
<p>So <code>f64</code> can not be complete and follow the standard at the same time.
Fortunately <code>PartialOrd</code> is implemented for <code>f64</code>. So as long as we do not
compare with <code>NaN</code>s, which we don't intend to do, we should be safe.</p>
<p>Back to sorting, the <code>sort</code> method expects that the <code>Ord</code> is implemented, so we
can not use it. <code>Vec&lt;T&gt;</code> also has a <code>sort_by</code> method, that allows to pass a <code>compare</code>
function. We can use this to our advantage by relying on the <code>PartialOrd</code> trait.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut vs: Vec&lt;f64&gt; = vec!(3.0, 2.0, 1.0);

vs.sort_by(|a, b| a.partial_cmp(b).unwrap());

println!(&quot;{:?}&quot;, vs);
#}</code></pre></pre>
<p>This correctly sorts our vector. But notice that the <code>vs</code> variable is declared
mutable. Our signature doesn't expect to have a mutable reference, so we need to
copy our <code>data</code> first.</p>
<a class="header" href="print.html#copying-data-1" id="copying-data-1"><h3>Copying Data</h3></a>
<p>We need a mutable copy of our <code>data</code>. Luckily the <code>Vec&lt;T&gt;</code> API provides an other
method; <code>copy_from_slice</code>. We use it as</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let n = data.len();
let mut copy = vec!(0f64; n);
copy.copy_from_slice(&amp;data);
#}</code></pre></pre>
<p>This is the final piece in the median puzzle. We are able to put everything
together and write our <code>median_of</code> function.</p>
<a class="header" href="print.html#form-groups-1" id="form-groups-1"><h3>Form Groups</h3></a>
<p>We do not want to calculate the median of our entire sequence. Instead we want
to move a <a href="https://en.wikipedia.org/wiki/Streaming_algorithm"><em>sliding window</em></a>
over our data and calculate the median of that specific window.</p>
<p>For that we need to group our data. Let's create that function.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn groups(data: &amp;Vec&lt;f64&gt;, group_size: usize) -&gt; Vec&lt;Vec&lt;f64&gt;&gt; {
    let mut groups: Vec&lt;Vec&lt;f64&gt;&gt; = vec!();

    for end_index in group_size .. data.len() + 1 {
        let mut group: Vec&lt;f64&gt; = vec!();
        for index in (end_index - group_size) .. end_index {
            group.push(data[index])
        }
        groups.push(group)
    }

    groups
}
#}</code></pre></pre>
<a class="header" href="print.html#median-filter-1" id="median-filter-1"><h3>Median Filter</h3></a>
<p>We are now in the position to create a <code>median_filter</code> function. I.e. a function
that calculates the median of a sliding window over our data. With all of our
preparations it writes itself as</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn median_filter(data: &amp;Vec&lt;f64&gt;, window: usize) -&gt; Vec&lt;f64&gt; {
    groups(data, window)
        .iter()
        .map(median_of)
        .collect()
}
#}</code></pre></pre>
<p>With our library all done, we can start out processing proper.</p>
<a class="header" href="print.html#processing-10" id="processing-10"><h2>Processing</h2></a>
<p>But wait! Our data arrives as <code>f64</code>-pairs, i.e. <code>(f64, f64)</code>, and we create
<code>median_filter</code> to operate on a single <code>f64</code> value. Did I lead you down a wrong
path?</p>
<p>Not entirely. Once again the standard library, in the form of the <code>Iter</code> trait,
has a trick up their sleeve. It comes in the pair of methods <code>zip</code> and <code>unzip</code>.
You can find their signatures below.
With <code>unzip</code> you can take a sequences of pairs and return a pair of sequences.
<code>zip</code> goes the other way.</p>
<p>Let's see how we can use them. After getting the raw data, we can use <code>unzip</code> to
extract the individual components.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let (times, values): (Vec&lt;f64&gt;, Vec&lt;f64&gt;) = raw
    .iter()
    .cloned()
    .unzip();
#}</code></pre></pre>
<p>The <code>cloned</code> call is because we need to take ownership of our data. Next we can
use our <code>median_filter</code> from our own library. Make sure to reference our own
external crate and import the correct function.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let median_times = median_filter(&amp;times, window_size);
let median_values = median_filter(&amp;values, window_size);
#}</code></pre></pre>
<p>Finally we can zip together these two vectors again to get our result.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let result = median_times.iter().zip(median_values);
#}</code></pre></pre>
<p>Storing this into a CSV file makes it available for the next step.</p>
<a class="header" href="print.html#further-considerations-13" id="further-considerations-13"><h2>Further Considerations</h2></a>
<p>You have created a library that contains some functions. How do you know that
they are implemented correctly? Try to add some
<a href="https://doc.rust-lang.org/book/second-edition/ch11-03-test-organization.html">tests</a>
that increases your confidence in your code.</p>
<p>The <code>median_filter</code> accepts an <code>window_size</code> argument. What is a good value?</p>
<p>Why haven't we used same the method we used to detrend the data?</p>
<a class="header" href="print.html#fitting-1" id="fitting-1"><h1>Fitting</h1></a>
<p>We have created a plot of the median.</p>
<p><img src="image/median.png" alt="The median of the filtered brightness" /></p>
<p>We would like to find planets in it. Finding planets amounts to selecting a
transit curve that nicely fits our data. We our going to divide that task in the
following sub-tasks.</p>
<ol>
<li>Generating a transit curve series</li>
<li>Iterating over all transit curve parameters</li>
<li>Scoring each candidate transit curve and selecting the best</li>
</ol>
<p>Let us create a module for this as well. We will call it <code>fit</code>.</p>
<a class="header" href="print.html#transit-curves-1" id="transit-curves-1"><h2>Transit Curves</h2></a>
<p><img src="image/period.png" alt="Multiple periods of a transit curves" /></p>
<p>The above image shows a typical transit curve where the planet transits the host
star multiple times. From this diagram we can learn about the parameters that
make up such a transit.</p>
<p>Below we list the parameters important in our transit curve.</p>
<ol>
<li><strong>Period</strong>. The time between the start of one transit and the start of the
next transit.</li>
<li><strong>Base</strong>. Height of the line, when no planet transits. This is often
normalized, but because of the choices we made, we need this parameter.</li>
<li><strong>Depth</strong>. How far the luminosity drops when the planets transits. This is
related to the size of the planet.</li>
<li><strong>Duration</strong>. How long the luminosity stays at full depth.</li>
<li><strong>Decay</strong>. How much time it takes the luminosity to go from the <code>base</code> to
<code>depth</code>. In our model the attack, i.e. time it takes the luminosity to go
from <code>depth</code> back to <code>base</code>, and decay are the same.</li>
<li><strong>Phase</strong>. Where in the period does the periodic function start.</li>
</ol>
<p>Below you find a <code>struct</code> and an implemented constructor that can track this
data.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Transit {
    period: f64,
    base: f64,
    depth: f64,
    duration: f64,
    decay: f64,
    phase: f64,
}

impl Transit {
    fn new((period, base, depth, duration, decay, phase): (f64,f64,f64,f64,f64,f64)) -&gt; Transit {
        Transit { period, base, depth, duration, decay, phase }
    }
}
#}</code></pre></pre>
<p>Notice that the <code>new</code> function accepts a tuple of floating point numbers. We
will use this when we iterate over the parameters.</p>
<p>What we also want to know is, when we have got a <code>time</code>, what is the
corresponding value of this transit curve. For that we are going to implement a
<code>value</code> method on `Transit</p>
<p>What we also want to know is, when we have got a <code>time, what is the corresponding value of this transit curve. For that we are going to implement a</code>value method on <code>Transit</code>.</p>
<p>The interesting times are</p>
<ol>
<li>Before the decay. The value should be <code>base</code></li>
<li>During the decay. The value should linearly interpolate between <code>base</code> and
<code>base</code> - <code>depth</code>.</li>
<li>During full transit. The value should be <code>base</code> - <code>depth</code></li>
<li>During the attack. The value should linearly interpolate between <code>base</code> -
<code>depth</code> and <code>base</code>.</li>
<li>After the transit. The value should be <code>base</code>.</li>
</ol>
<p>Implement the above logic into a <code>value</code> method for <code>Transit</code>.</p>
<a class="header" href="print.html#iterate-parameters-1" id="iterate-parameters-1"><h2>Iterate Parameters</h2></a>
<p>Our transit curve has five parameters. We would like to generate candidate
transit curves and check how well they fit our data. This can be accomplished by
iterating over the five parameters, and mapping them into a transit curve.</p>
<a class="header" href="print.html#floatiterator-1" id="floatiterator-1"><h3>FloatIterator</h3></a>
<p>We will first focus on an iterator for a single <code>f64</code>. We want all floating
point numbers between a <code>start</code> and <code>finish</code>, increasing each new number with a
certain <code>step</code>. We will create a <code>struct</code> that keeps track of where we are.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct FloatIterator {
    start: f64,
    finish: f64,
    step: f64,
    current: u64,
}
#}</code></pre></pre>
<p>Implementing a <code>new</code> constructor should set the <code>current</code> to <code>0</code> and accept
<code>start</code>, <code>finish</code> and step as parameters.</p>
<p>Next we need to implement <code>Iterator</code> for <code>FloatIterator</code>. We must import
<code>std::iter::Iterator</code> so that we can easily reference it in our code. In the
<code>next</code> method of the <code>Iterator</code> trait we need to decide if we need to return a
<code>Some</code> or a <code>None</code>. This depends on the our intended return value. I.e. if the
value <code>start + step * current</code> is less then or equal to our <code>finish</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Iterator for FloatIterator {
    type Item = f64;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let value = self.start + self.step * (self.current as f64);

        if value &lt;= self.finish {
            self.current += 1;

            Some(value)
        } else {
            None
        }
    }
}
#}</code></pre></pre>
<p>This wraps up our <code>FloatIterator</code>.</p>
<a class="header" href="print.html#exemplar-tupleiterator-1" id="exemplar-tupleiterator-1"><h3>Exemplar TupleIterator</h3></a>
<p>Next we are going to create a <code>TupleIterator</code>. It is going to show all the
necessary tools to create the actual <code>TupleIterator</code> we want, without getting
distracted by the tedious details.</p>
<p>Because we want to express multiple times a range of floating point numbers we
are interested in, we are going to create a <code>struct</code> to keep track of <code>start</code>,
<code>finish</code> and <code>step</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct FloatRange {
    start: f64,
    finish: f64,
    step: f64,
}
#}</code></pre></pre>
<p>implementing a <code>new</code> constructor for <code>FloatRange</code> is nothing more than excepting
the correct parameters and passing them in the struct. Having a <code>FloatRange</code>
allows us to ask it for the value belonging to a certain index. Let's extend the
implementation of <code>FloatRange</code> with an <code>index</code> function. The actual
implementation looks very familiar.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn index(&amp;self, index: u64) -&gt; Option&lt;f64&gt; {
    let value = self.start + self.step * (index as f64);

    if value &lt;= self.finish {
        Some(value)
    } else {
        None
    }
}
#}</code></pre></pre>
<p>Now that we can express the floating point range we are interested in, we can
use that in our <code>TupleIterator</code>. The responsibility of the <code>TupleIterator</code> is to
keep track of two indices into two separate <code>FloatIterator</code>. Because we need to
be able to &quot;restart&quot; the <code>FloatIterator</code> we are not actually use a
<code>FloatIterator</code>. Instead we choose to do the iterating our selves.</p>
<p>We start with a structure that will keep track for us.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct TupleIterator {
    first: FloatRange,
    second: FloatRange,
    current: (u64, u64),
}
#}</code></pre></pre>
<p>It looks a lot like the <code>FloatIterator</code>. The main difference is that we need to
keep track of two different ranges, and two different indices into these
iterators. Implementing a new is just like the <code>FloatIterator</code> little more than
accepting the correct parameters and initializing the current indices to
<code>(0,0)</code>.</p>
<p>Now for implementing <code>Iterator</code> for <code>TupleIterator</code>. It comes down to keeping
track of the right indices. Let's look at the implementation.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Iterator for TupleIterator {
    type Item = (f64, f64);

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let (first_index, second_index) = self.current;

        match self.first.index(first_index) {
            Some(first_value) =&gt; {
                match self.second.index(second_index) {
                    Some(second_value) =&gt; {
                        self.current = (first_index, second_index + 1);

                        Some((first_value, second_value))
                    },

                    None =&gt; {
                        self.current = (first_index + 1, 0);

                        self.next()
                    },
                }
            },

            None =&gt; None,
        }
    }
}
#}</code></pre></pre>
<p>Reading the code, we discover that we determine two values, one for each
<code>FloatRange</code>. If the first <code>FloatRange</code> return <code>None</code> we are done. If it returns
some value, we see what the second <code>FloatRange</code> returns. If that also returns
some value, we do the following things.</p>
<ol>
<li>Increment the second index.</li>
<li>Return the tuple of values.</li>
</ol>
<p>If the second <code>FloatRange</code> doesn't return some value, we know that it exhausted
its range. We then increment the first index, resetting the second index. In
effect we want to the second iterator from scratch, but with a new first value.
Next we use the power of recursion to determine what the value should be with
the new indices.</p>
<p>Although it doesn't look pretty, it does its job. It is your task to extend this
example to iterate over all transit parameters.</p>
<a class="header" href="print.html#score-1" id="score-1"><h2>Score</h2></a>
<p>We are going to score a <code>Transit</code> with the
<a href="https://en.wikipedia.org/wiki/Least_squares"><em>least squares</em></a> method. This
method sums the squares of the difference between two series. That is easier
said than done. Lets look at following code.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn least_squares(xs: &amp;Vec&lt;f64&gt;, ys: &amp;Vec&lt;f64&gt;) -&gt; f64 {
    xs.iter().zip(ys)
        .map(|(a,b)| (a-b).powi(2))
        .sum()
}
#}</code></pre></pre>
<p>We define a function names <code>least_squares</code> that accepts to vectors of floating
points numbers. Next we recognize our dear friend: the <code>iter</code> method. We use it
on the first vector and zip it with the second vector. On the vector of pairs we
map the function that calculates the squared difference. We finish with summing
all the numbers, getting our result.</p>
<p>With all the parts in place we are ready to start processing.</p>
<a class="header" href="print.html#processing-11" id="processing-11"><h2>Processing</h2></a>
<p>We need to compare candidate transit curves with our median, so we need to read our <code>median.csv</code>. Because we would like to process the times and the values separedly we use the <code>unzip</code> trick we learned earlier.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let (times, values): (Vec&lt;f64&gt;, Vec&lt;f64&gt;) = raw
    .iter()
    .cloned()
    .unzip();
#}</code></pre></pre>
<p>Processing consist for a big part of a main loop that iterates over our transit parameters. This is depend on a number of <code>FloatRange</code>s and this is where you can shine. By looking at your <code>median.csv</code> data you can guess good ranges, and with some luck you will find planets.</p>
<p>We need to keep track of the best transit curve. So we initialize variables before our main loop.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut best_score = f64::MAX;
let mut best_transit: Option&lt;Transit&gt; = None;
#}</code></pre></pre>
<p>In order to make use of the <code>f64::MAX</code> we need to import <code>std::f64</code>. Not that the best score will actually be the lowest value, so it is save to initialize it to the maximum value.</p>
<p>Inside our loop, we can create a transit curve from the parameters.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let transit = Transit::new(parameters);
#}</code></pre></pre>
<p>The <code>transit</code> can be used to determine the values at the times we observed by mapping over the <code>times</code> and using the <code>value</code> method.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let transit_values: Vec&lt;f64&gt; = times.iter().map(|t| transit.value(t)).collect();
#}</code></pre></pre>
<p>Scoring is little more than calling the right function.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let score = least_squares(&amp;transit_values, &amp;values);
#}</code></pre></pre>
<p>Now that we have the score, we need to compare it with the best score we now about, and update our best candidate accordingly.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
if score &lt; best_score {
    best_score = score;
    best_transit = Some(transit.clone());
}
#}</code></pre></pre>
<p>When the loop finishes we would like to know which transit is the best. So we prepare to print it to console, and calculate the actual values, which you can write to a CSV file.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let best_transit = best_transit.unwrap();
let best_transit_values: Vec&lt;f64&gt; = times.iter().map(|t| best_transit.value(t)).collect();
println!(&quot;{:?}&quot;, best_transit);

let result = times.iter().zip(best_transit_values);
#}</code></pre></pre>
<p>Lets fly through our candidates and see what planet you can find.</p>
<a class="header" href="print.html#further-considerations-14" id="further-considerations-14"><h2>Further Considerations</h2></a>
<p>How do you know that you implemented the various libraries correctly? Have you tested them?</p>
<p>The way that we generate our transit parameters is going through all possible values. This seems a bit wastefull. Can you come up with a better way? Discussing your thoughts with somebody.</p>
<p>We used the method of least squares to score a transit curve. What other scoring mechanism can you think of. What difference would it make?</p>
<a class="header" href="print.html#reflection" id="reflection"><h1>Reflection</h1></a>
<p>We just experienced a whirlwind tour of code and science. It is good to reflect on what we did.</p>
<p>We learned that raw data needs to be processed before we actually can use it. Along the way we learned a few tricks how to clean up data. We got to know transit curves and what makes them tick. And we appreciated the difficult task of finding planets.</p>
<a class="header" href="print.html#improvements" id="improvements"><h2>Improvements</h2></a>
<p>In this workshop we demonstrated in a very crude way how one can detect planets. The science of exo-planets is a very rich and interesting field. The models they use to routinely scan for planets is far more elaborate.</p>
<p>None-the-less, with our simple understanding gives us a lot of insight into the study of exo-planets.</p>
<a class="header" href="print.html#most-important" id="most-important"><h2>Most Important</h2></a>
<p>Most Importantly, I hope you had fun.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
